
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Item 1 Limit Mutability · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Item 2 Minimize the scope of variables.html" />
    
    
    <link rel="prev" href="Introduction.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Part 1 Good Code
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" >
            
                <span>
            
                    
                    Chapter 1 Safety
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" data-path="Introduction.html">
            
                <a href="Introduction.html">
            
                    
                    引言
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.1.2" data-path="Item 1 Limit mutability.html">
            
                <a href="Item 1 Limit mutability.html">
            
                    
                    Item 1 Limit Mutability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.3" data-path="Item 2 Minimize the scope of variables.html">
            
                <a href="Item 2 Minimize the scope of variables.html">
            
                    
                    第2条：最小化变量作用域
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.4" data-path="Item 3 Eliminate platform types as soon as possible.html">
            
                <a href="Item 3 Eliminate platform types as soon as possible.html">
            
                    
                    Item 3 Eliminate Platform Types As Soon As Possible
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.5" data-path="Item 4 Do not expose inferred types.html">
            
                <a href="Item 4 Do not expose inferred types.html">
            
                    
                    第4条：不要把推断类型暴露给外部
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.6" data-path="Item 5 Specify your expectations on arguments and state.html">
            
                <a href="Item 5 Specify your expectations on arguments and state.html">
            
                    
                    Item 5 Specify Your Expectations On Arguments And State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.7" data-path="Item 6 Prefer standard errors to custom ones.html">
            
                <a href="Item 6 Prefer standard errors to custom ones.html">
            
                    
                    第6条：尽可能使用标准库中提供的异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.8" data-path="Item 7 Prefer null or Failure result when the lack of result is possible.html">
            
                <a href="Item 7 Prefer null or Failure result when the lack of result is possible.html">
            
                    
                    Item 7 Prefer Null Or Failure Result When The Lack Of Result Is Possible
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.9" data-path="Item 8 Handle nulls properly.html">
            
                <a href="Item 8 Handle nulls properly.html">
            
                    
                    Item 8 Handle Nulls Properly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.10" data-path="Item 9 Close resources with use.html">
            
                <a href="Item 9 Close resources with use.html">
            
                    
                    Item 9 Close Resources With Use
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.11" data-path="Item 10 Write unit tests.html">
            
                <a href="Item 10 Write unit tests.html">
            
                    
                    Item 10 Write Unit Tests
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.2" >
            
                <span>
            
                    
                    Chapter 2 Readability
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.2.1" data-path="../Chapter 2 Readability/Introduction.html">
            
                <a href="../Chapter 2 Readability/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.2" data-path="../Chapter 2 Readability/Item 11 Design for readability.html">
            
                <a href="../Chapter 2 Readability/Item 11 Design for readability.html">
            
                    
                    Item 11 Design For Readability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.3" data-path="../Chapter 2 Readability/Item 12 Operator meaning should be consistent with its function name.html">
            
                <a href="../Chapter 2 Readability/Item 12 Operator meaning should be consistent with its function name.html">
            
                    
                    Item 12 Operator Meaning Should Be Consistent With Its Function Name
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.4" data-path="../Chapter 2 Readability/Item 13 Avoid returning or operating on Unit?.md">
            
                <span>
            
                    
                    Item 13 Avoid Returning Or Operating On Unit
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.5" data-path="../Chapter 2 Readability/Item 14 Specify the variable type when it is not clear.html">
            
                <a href="../Chapter 2 Readability/Item 14 Specify the variable type when it is not clear.html">
            
                    
                    Item 14 Specify The Variable Type When It Is Not Clear
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.6" data-path="../Chapter 2 Readability/Item 15 Consider referencing receivers explicitly.html">
            
                <a href="../Chapter 2 Readability/Item 15 Consider referencing receivers explicitly.html">
            
                    
                    Item 15 Consider Referencing Receivers Explicitly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.7" data-path="../Chapter 2 Readability/Item 16 Properties should represent state not behavior.html">
            
                <a href="../Chapter 2 Readability/Item 16 Properties should represent state not behavior.html">
            
                    
                    Item 16 Properties Should Represent State Not Behavior
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.8" data-path="../Chapter 2 Readability/Item 17 Consider naming arguments.html">
            
                <a href="../Chapter 2 Readability/Item 17 Consider naming arguments.html">
            
                    
                    Item 17 Consider Naming Arguments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.9" data-path="../Chapter 2 Readability/Item 18 Respect coding conventions.html">
            
                <a href="../Chapter 2 Readability/Item 18 Respect coding conventions.html">
            
                    
                    Item 18 Respect Coding Conventions
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Part 2 Code Design
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    Chapter 3 Reusability
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="../../Part 2 Code design/Chapter 3 Reusability/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 19 Do not repeat knowledge.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 19 Do not repeat knowledge.html">
            
                    
                    Item 19 Do Not Repeat Knowledge
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 20 Do not repeat common algorithms.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 20 Do not repeat common algorithms.html">
            
                    
                    Item 20 Do Not Repeat Common Algorithms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 21 Use property delegation to extract common property patterns.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 21 Use property delegation to extract common property patterns.html">
            
                    
                    Item 21 Use Property Delegation To Extract Common Property Patterns
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 22 Use generics when implementing common algorithms.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 22 Use generics when implementing common algorithms.html">
            
                    
                    Item 22 Use Generics When Implementing Common Algorithms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.6" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 23 Avoid shadowing type parameters.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 23 Avoid shadowing type parameters.html">
            
                    
                    Item 23 Avoid Shadowing Type Parameters
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.7" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 24 Consider variance for generic types.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 24 Consider variance for generic types.html">
            
                    
                    Item 24 Consider Variance For Generic Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.8" data-path="../../Part 2 Code design/Chapter 3 Reusability/Item 25 Reuse between different platforms by extracting common modules.html">
            
                <a href="../../Part 2 Code design/Chapter 3 Reusability/Item 25 Reuse between different platforms by extracting common modules.html">
            
                    
                    Item 25 Reuse Between Different Platforms By Extracting Common Modules
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2" >
            
                <span>
            
                    
                    Chapter 4 Abstraction Design
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.1" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.2" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 26 Each function should be written in terms of a single level of abstraction.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 26 Each function should be written in terms of a single level of abstraction.html">
            
                    
                    Item 26 Each Function Should Be Written In Terms Of A Single Level Of Abstraction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.3" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 27 Use abstraction to protect code against changes.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 27 Use abstraction to protect code against changes.html">
            
                    
                    Item 27 Use Abstraction To Protect Code Against Changes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 28 Specify API stability.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 28 Specify API stability.html">
            
                    
                    Item 28 Specify API Stability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.5" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 29 Consider wrapping external API.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 29 Consider wrapping external API.html">
            
                    
                    Item 29 Consider Wrapping External API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.6" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 30 Minimize elements visibility.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 30 Minimize elements visibility.html">
            
                    
                    Item 30 Minimize Elements Visibility
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.7" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 31 Define contract with documentation.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 31 Define contract with documentation.html">
            
                    
                    Item 31 Define Contract With Documentation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.8" data-path="../../Part 2 Code design/Chapter 4 Abstraction design/Item 32 Respect abstraction contracts.html">
            
                <a href="../../Part 2 Code design/Chapter 4 Abstraction design/Item 32 Respect abstraction contracts.html">
            
                    
                    Item 32 Respect Abstraction Contracts
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.3" >
            
                <span>
            
                    
                    Chapter 5 Object Creation
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.3.1" data-path="../../Part 2 Code design/Chapter 5 Object creation/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.2" data-path="../../Part 2 Code design/Chapter 5 Object creation/Item 33 Consider factory functions instead of constructors.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Item 33 Consider factory functions instead of constructors.html">
            
                    
                    Item 33 Consider Factory Functions Instead Of Constructors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.3" data-path="../../Part 2 Code design/Chapter 5 Object creation/Item 34 Consider a primary constructor with named optional arguments.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Item 34 Consider a primary constructor with named optional arguments.html">
            
                    
                    Item 34 Consider A Primary Constructor With Named Optional Arguments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3.4" data-path="../../Part 2 Code design/Chapter 5 Object creation/Item 35 Consider defining a DSL for complex object creation.html">
            
                <a href="../../Part 2 Code design/Chapter 5 Object creation/Item 35 Consider defining a DSL for complex object creation.html">
            
                    
                    Item 35 Consider Defining A DSL For Complex Object Creation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.4" >
            
                <span>
            
                    
                    Chapter 6 Class Design
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.4.1" data-path="../../Part 2 Code design/Chapter 6 Class design/Introduction.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.2" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 36 Prefer composition over inheritance.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 36 Prefer composition over inheritance.html">
            
                    
                    Item 36 Prefer Composition Over Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.3" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 37 Use the data modifier to represent a bundle of data.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 37 Use the data modifier to represent a bundle of data.html">
            
                    
                    Item 37 Use The Data Modifier To Represent A Bundle Of Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.4" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 38 Use function types instead of interfaces to pass operations and actions.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 38 Use function types instead of interfaces to pass operations and actions.html">
            
                    
                    Item 38 Use Function Types Instead Of Interfaces To Pass Operations And Actions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.5" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 39 Prefer class hierarchies to tagged classes.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 39 Prefer class hierarchies to tagged classes.html">
            
                    
                    Item 39 Prefer Class Hierarchies To Tagged Classes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.6" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 40 Respect the contract of  equals.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 40 Respect the contract of  equals.html">
            
                    
                    Item 40 Respect The Contract Of Equals
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.7" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 41 Respect the contract of  hashCode.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 41 Respect the contract of  hashCode.html">
            
                    
                    Item 41 Respect The Contract Of Hash Code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.8" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 42 Respect the contract of compareTo.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 42 Respect the contract of compareTo.html">
            
                    
                    Item 42 Respect The Contract Of Compare To
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.9" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 43 Consider extracting non-essential parts of your API into extensions.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 43 Consider extracting non-essential parts of your API into extensions.html">
            
                    
                    Item 43 Consider Extracting Non Essential Parts Of Your API Into Extensions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.10" data-path="../../Part 2 Code design/Chapter 6 Class design/Item 44 Avoid member extensions.html">
            
                <a href="../../Part 2 Code design/Chapter 6 Class design/Item 44 Avoid member extensions.html">
            
                    
                    Item 44 Avoid Member Extensions
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Part 3 Efficiency
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" >
            
                <span>
            
                    
                    Chapter 7 Make It Cheap
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1.1" data-path="../../Part 3 Efficiency/Chapter 7 Make it cheap/Introduction.html">
            
                <a href="../../Part 3 Efficiency/Chapter 7 Make it cheap/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.2" data-path="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 45 Avoid unnecessary object creation.html">
            
                <a href="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 45 Avoid unnecessary object creation.html">
            
                    
                    Item 45 Avoid Unnecessary Object Creation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.3" data-path="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 46 Use inline modifier for functions with parameters of functional types.html">
            
                <a href="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 46 Use inline modifier for functions with parameters of functional types.html">
            
                    
                    Item 46 Use Inline Modifier For Functions With Parameters Of Functional Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.4" data-path="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 47 Consider using inline classes.html">
            
                <a href="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 47 Consider using inline classes.html">
            
                    
                    Item 47 Consider Using Inline Classes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.1.5" data-path="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 48 Eliminate obsolete object references.html">
            
                <a href="../../Part 3 Efficiency/Chapter 7 Make it cheap/Item 48 Eliminate obsolete object references.html">
            
                    
                    Item 48 Eliminate Obsolete Object References
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.2" >
            
                <span>
            
                    
                    Chapter 8 Efficient Collection Processing
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.2.1" data-path="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Introduction.html">
            
                <a href="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.2" data-path="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 49 Prefer Sequence for big collections with more than one processing step.html">
            
                <a href="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 49 Prefer Sequence for big collections with more than one processing step.html">
            
                    
                    Item 49 Prefer Sequence For Big Collections With More Than One Processing Step
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.3" data-path="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 50 Limit the number of operations.html">
            
                <a href="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 50 Limit the number of operations.html">
            
                    
                    Item 50 Limit The Number Of Operations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.4" data-path="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 51 Consider Arrays with primitives for performance-critical processing.html">
            
                <a href="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 51 Consider Arrays with primitives for performance-critical processing.html">
            
                    
                    Item 51 Consider Arrays With Primitives For Performance Critical Processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2.5" data-path="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 52 Consider using mutable collections.html">
            
                <a href="../../Part 3 Efficiency/Chapter 8 Efficient collection processing/Item 52 Consider using mutable collections.html">
            
                    
                    Item 52 Consider Using Mutable Collections
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Item 1 Limit Mutability</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>&#x5728;kotlin&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x8BBE;&#x8BA1;&#x4E00;&#x6BB5;&#x4EE3;&#x7801;&#xFF0C;&#x6BCF;&#x6BB5;&#x4EE3;&#x7801;&#x7531;&#x4E0D;&#x540C;&#x7684;&#x5143;&#x7D20;&#x7EC4;&#x6210;&#x3002;&#x4F8B;&#x5982;&#x7C7B;&#x3001;&#x5BF9;&#x8C61;&#x3001;&#x51FD;&#x6570;&#x3001;&#x7C7B;&#x578B;&#x522B;&#x540D;&#x548C;&#x9876;&#x7EA7;&#x5C5E;&#x6027;&#x3002;&#x5176;&#x4E2D;&#x4E00;&#x4E9B;&#x5143;&#x7D20;&#x53EF;&#x4EE5;&#x4FDD;&#x5B58;&#x72B6;&#x6001;&#xFF0C;&#x4F8B;&#x5982;&#x901A;&#x8FC7;&#x5177;&#x6709;&#x53EF;&#x8BFB;&#x5199;&#x5C5E;&#x6027;&#x7684;var&#x6216;&#x4E00;&#x4E2A;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x3002;</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">var</span> a</span> = <span class="hljs-number">10</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> list</span>: MutableList<span class="hljs-type">&lt;Int&gt;</span> = mutableListOf()
</code></pre>
<p>&#x5F53;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x4FDD;&#x5B58;&#x4FE1;&#x606F;&#x72B6;&#x6001;&#x65F6;&#xFF0C;&#x5B83;&#x7684;&#x8C03;&#x7528;&#x7ED3;&#x679C;&#x4E0D;&#x4EC5;&#x53D6;&#x51B3;&#x4E8E;&#x60A8;&#x5982;&#x4F55;&#x4F7F;&#x7528;&#x5B83;&#xFF0C;&#x8FD8;&#x53D6;&#x51B3;&#x4E8E;&#x5B83;&#x4E4B;&#x524D;&#x88AB;&#x5982;&#x4F55;&#x4F7F;&#x7528;&#x3002;&#x4E00;&#x4E2A;&#x5178;&#x578B;&#x7684;&#x4F8B;&#x5B50;&#x5982;&#x4E0B;&#xFF0C;&#x5E26;&#x6709;&#x5B58;&#x6B3E;&#x4F59;&#x989D;&#x7684;&#x8D26;&#x6237;&#x3002;</p>
<pre><code class="lang-kotlin"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankAccount</span> </span>{
    <span class="hljs-variable"><span class="hljs-keyword">var</span> balance</span> = <span class="hljs-number">0.0</span>
       <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deposit</span><span class="hljs-params">(depositAmount: <span class="hljs-type">Double</span>)</span> {</span>
        balance += depositAmount
    }

    @Throws(InsufficientFunds::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(withdrawAmount: <span class="hljs-type">Double</span>)</span> {</span>
        <span class="hljs-keyword">if</span> (balance <span class="hljs-type">&lt; withdrawAmount) {
            throw InsufficientFunds()
        }
        balance -= withdrawAmount
    }
 }

 class InsufficientFunds : Exception()

 val account = BankAccount()
 println(account.balance) // 0.0
 account.deposit(100.0)
 println(account.balance) // 100.0
 account.withdraw(50.0)
 println(account.balance) // 50.0
</span></code></pre>
<p>Here BankAccount has a state that represents how much money is present on that account. Holding state is a double-edged sword. On one hand it is very useful because it makes it possible to represent elements changing over time, but on the other hand state management is hard, because:
&#x8FD9;&#x91CC;BankAccount&#x6709;&#x4E00;&#x4E2A;&#x503C;&#xFF0C;&#x8868;&#x793A;&#x8BE5;&#x8D26;&#x6237;&#x4E0A;&#x5B58;&#x5728;&#x591A;&#x5C11;&#x94B1;&#x3002;&#x6301;&#x6709;&#x8FD9;&#x4E2A;&#x503C;&#x662F;&#x4E00;&#x628A;&#x53CC;&#x5203;&#x5251;&#x3002;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x5B83;&#x975E;&#x5E38;&#x6709;&#x7528;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x53EF;&#x4EE5;&#x8868;&#x793A;&#x968F;&#x65F6;&#x95F4;&#x53D8;&#x5316;&#x7684;&#x5143;&#x7D20;&#xFF0C;&#x4F46;&#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x72B6;&#x6001;&#x7BA1;&#x7406;&#x5F88;&#x96BE;&#xFF0C;&#x539F;&#x56E0;&#x5982;&#x4E0B;:</p>
<ol>
<li><p>It is harder to understand and debug a program with many mutating points. The relationship between these mutations needs to be understood, and it is harder to track how they changed when there are more of them. A class with many mutating points that depend on each other is often really hard to understand and to modify. It is especially problematic in case of unexpected situations or errors.</p>
</li>
<li><p>&#x6709;&#x8BB8;&#x591A;&#x7A81;&#x53D8;&#x70B9;&#x7684;&#x7A0B;&#x5E8F;&#x66F4;&#x96BE;&#x7406;&#x89E3;&#x548C;&#x8C03;&#x8BD5;&#x3002;&#x8FD9;&#x4E9B;&#x7A81;&#x53D8;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x7CFB;&#x9700;&#x8981;&#x88AB;&#x7406;&#x89E3;&#xFF0C;&#x800C;&#x4E14;&#x5F53;&#x5B83;&#x4EEC;&#x7684;&#x6570;&#x91CF;&#x66F4;&#x591A;&#x65F6;&#xFF0C;&#x5F88;&#x96BE;&#x8FFD;&#x8E2A;&#x5B83;&#x4EEC;&#x662F;&#x5982;&#x4F55;&#x53D8;&#x5316;&#x7684;&#x3002;&#x5177;&#x6709;&#x8BB8;&#x591A;&#x76F8;&#x4E92;&#x4F9D;&#x8D56;&#x7684;&#x7A81;&#x53D8;&#x70B9;&#x7684;&#x7C7B;&#x901A;&#x5E38;&#x5F88;&#x96BE;&#x7406;&#x89E3;&#x548C;&#x4FEE;&#x6539;&#x3002;&#x5728;&#x51FA;&#x73B0;&#x610F;&#x60F3;&#x4E0D;&#x5230;&#x7684;&#x60C5;&#x51B5;&#x6216;&#x9519;&#x8BEF;&#x65F6;&#xFF0C;&#x5B83;&#x5C24;&#x5176;&#x6709;&#x95EE;&#x9898;&#x3002;</p>
</li>
<li><p>Mutability makes it harder to reason about the code. State of immutable element is clear. Mutable state is much harder to comprehend. It is harder to reason what is its value as it might change at any point and just because we checked in some moment it doesn&#x2019;t mean it is still the same.</p>
</li>
<li><p>&#x6613;&#x53D8;&#x6027;&#x4F7F;&#x5F97;&#x5BF9;&#x4EE3;&#x7801;&#x8FDB;&#x884C;&#x63A8;&#x7406;&#x53D8;&#x5F97;&#x66F4;&#x52A0;&#x56F0;&#x96BE;&#x3002;&#x4E0D;&#x53EF;&#x53D8;&#x5143;&#x7D20;&#x7684;&#x72B6;&#x6001;&#x662F;&#x6E05;&#x6670;&#x7684;&#x3002;&#x53EF;&#x53D8;&#x72B6;&#x6001;&#x66F4;&#x96BE;&#x7406;&#x89E3;&#x3002;&#x5F88;&#x96BE;&#x63A8;&#x65AD;&#x5B83;&#x7684;&#x503C;&#x662F;&#x591A;&#x5C11;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x53EF;&#x80FD;&#x4F1A;&#x5728;&#x4EFB;&#x4F55;&#x65F6;&#x5019;&#x6539;&#x53D8;&#xFF0C;&#x4EC5;&#x4EC5;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x5728;&#x67D0;&#x4E2A;&#x65F6;&#x523B;&#x68C0;&#x67E5;&#x5B83;&#x5E76;&#x4E0D;&#x610F;&#x5473;&#x7740;&#x5B83;&#x4ECD;&#x7136;&#x662F;&#x76F8;&#x540C;&#x7684;&#x3002;</p>
</li>
<li><p>It requires proper synchronization in multithreaded programs.Every mutation is a potential conflict.</p>
</li>
<li><p>&#x5728;&#x591A;&#x7EBF;&#x7A0B;&#x7A0B;&#x5E8F;&#x4E2D;&#x9700;&#x8981;&#x9002;&#x5F53;&#x7684;&#x540C;&#x6B65;&#x3002;&#x6BCF;&#x4E00;&#x4E2A;&#x7A81;&#x53D8;&#x90FD;&#x662F;&#x6F5C;&#x5728;&#x7684;&#x51B2;&#x7A81;&#x3002;</p>
</li>
<li><p>Mutable elements are harder to test. We need to test every possible state, and the more mutability, the more states there are to test. What is more, the number of states we need to test generally grows exponentially with the number of mutation points in the same object or file, as we need to test all different combinations of possible states.</p>
</li>
<li>&#x53EF;&#x53D8;&#x5143;&#x7D20;&#x66F4;&#x96BE;&#x6D4B;&#x8BD5;&#x3002;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x6D4B;&#x8BD5;&#x6240;&#x6709;&#x53EF;&#x80FD;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x800C;&#x53EF;&#x53D8;&#x6027;&#x8D8A;&#x5927;&#xFF0C;&#x9700;&#x8981;&#x6D4B;&#x8BD5;&#x7684;&#x72B6;&#x6001;&#x5C31;&#x8D8A;&#x591A;&#x3002;&#x66F4;&#x91CD;&#x8981;&#x7684;&#x662F;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x6D4B;&#x8BD5;&#x7684;&#x72B6;&#x6001;&#x7684;&#x6570;&#x91CF;&#x901A;&#x5E38;&#x968F;&#x7740;&#x540C;&#x4E00;&#x5BF9;&#x8C61;&#x6216;&#x6587;&#x4EF6;&#x4E2D;&#x7A81;&#x53D8;&#x70B9;&#x7684;&#x6570;&#x91CF;&#x5448;&#x6307;&#x6570;&#x589E;&#x957F;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x6D4B;&#x8BD5;&#x6240;&#x6709;&#x53EF;&#x80FD;&#x72B6;&#x6001;&#x7684;&#x4E0D;&#x540C;&#x7EC4;&#x5408;&#x3002;</li>
<li>When state mutates, often some other classes need to be notified about this change. For instance, when we add a mutable element to a sorted list, once the element is changed, we need to sort this list again.</li>
<li>&#x5F53;&#x72B6;&#x6001;&#x53D1;&#x751F;&#x53D8;&#x5316;&#x65F6;&#xFF0C;&#x901A;&#x5E38;&#x9700;&#x8981;&#x901A;&#x77E5;&#x5176;&#x4ED6;&#x4E00;&#x4E9B;&#x7C7B;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x5F53;&#x6211;&#x4EEC;&#x5411;&#x4E00;&#x4E2A;&#x5DF2;&#x6392;&#x5E8F;&#x7684;&#x5217;&#x8868;&#x4E2D;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;&#x53EF;&#x53D8;&#x7684;&#x5143;&#x7D20;&#x65F6;&#xFF0C;&#x4E00;&#x65E6;&#x5143;&#x7D20;&#x53D1;&#x751F;&#x6539;&#x53D8;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x9700;&#x8981;&#x518D;&#x6B21;&#x5BF9;&#x8FD9;&#x4E2A;&#x5217;&#x8868;&#x8FDB;&#x884C;&#x6392;&#x5E8F;&#x3002;</li>
</ol>
<p>Problems with state consistency and the growing complexity of the project with more mutation points are familiar for developers working in bigger teams. Let&#x2019;s see an example of how hard it is to manage shared state. Take a look at the below snippet&#x2076;. It shows multiple threads trying to modify the same property, however because of conflicts some of those operations will be lost.
&#x72B6;&#x6001;&#x4E00;&#x81F4;&#x6027;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x4EE5;&#x53CA;&#x9879;&#x76EE;&#x590D;&#x6742;&#x6027;&#x7684;&#x589E;&#x957F;&#xFF0C;&#x4EE5;&#x53CA;&#x66F4;&#x591A;&#x7684;&#x7A81;&#x53D8;&#x70B9;&#xFF0C;&#x5BF9;&#x4E8E;&#x5728;&#x66F4;&#x5927;&#x7684;&#x56E2;&#x961F;&#x4E2D;&#x5DE5;&#x4F5C;&#x7684;&#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x6765;&#x8BF4;&#x662F;&#x5F88;&#x719F;&#x6089;&#x7684;&#x3002;&#x8BA9;&#x6211;&#x4EEC;&#x770B;&#x4E00;&#x4E2A;&#x4F8B;&#x5B50;&#xFF0C;&#x770B;&#x770B;&#x7BA1;&#x7406;&#x5171;&#x4EAB;&#x72B6;&#x6001;&#x6709;&#x591A;&#x96BE;&#x3002;&#x770B;&#x770B;&#x4E0B;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x7247;&#x6BB5;&#x2076;&#x3002;&#x5B83;&#x663E;&#x793A;&#x4E86;&#x8BD5;&#x56FE;&#x4FEE;&#x6539;&#x76F8;&#x540C;&#x5C5E;&#x6027;&#x7684;&#x591A;&#x4E2A;&#x7EBF;&#x7A0B;&#xFF0C;&#x4F46;&#x662F;&#x7531;&#x4E8E;&#x51B2;&#x7A81;&#xFF0C;&#x5176;&#x4E2D;&#x4E00;&#x4E9B;&#x64CD;&#x4F5C;&#x5C06;&#x4E22;&#x5931;&#x3002;</p>
<pre><code class="lang-kotlin"> <span class="hljs-variable"><span class="hljs-keyword">var</span> num</span> = <span class="hljs-number">0</span>
 <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.1000</span>) {
    thread {
        Thread.sleep(<span class="hljs-number">10</span>)
        num += <span class="hljs-number">1</span>
    }
 }
 Thread.sleep(<span class="hljs-number">5000</span>)
 print(num) <span class="hljs-comment">// Very unlikely to be 1000</span>
 <span class="hljs-comment">// Every time a different number</span>
</code></pre>
<p>&#x5F53;&#x6211;&#x4EEC;&#x4F7F;&#x7528;Kotlin&#x534F;&#x7A0B;&#x65F6;&#xFF0C;&#x4F1A;&#x6709;&#x66F4;&#x5C11;&#x7684;&#x51B2;&#x7A81;&#xFF0C;&#x56E0;&#x4E3A;&#x6D89;&#x53CA;&#x7684;&#x7EBF;&#x7A0B;&#x66F4;&#x5C11;&#xFF0C;&#x4F46;&#x5B83;&#x4EEC;&#x4ECD;&#x7136;&#x4F1A;&#x53D1;&#x751F;</p>
<pre><code class="lang-kotlin">suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-variable"><span class="hljs-keyword">var</span> num</span> = <span class="hljs-number">0</span>
    coroutineScope {
        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.1000</span>) {
            launch {
                delay(<span class="hljs-number">10</span>)
                num += <span class="hljs-number">1</span>
            }
        }
    }
    print(num) <span class="hljs-comment">// Every time a different number</span>
}
</code></pre>
<p>In real-life projects, we generally cannot just lose some operations, and so we need to implement proper synchronization like the one presented below. Although implementing proper synchronization is hard, and the more mutation points we have, the harder it is. Limiting mutability does help.
&#x5728;&#x73B0;&#x5B9E;&#x7684;&#x9879;&#x76EE;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x901A;&#x5E38;&#x4E0D;&#x80FD;&#x4E0D;&#x53BB;&#x505A;&#x4E00;&#x4E9B;&#x5FC5;&#x8981;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x56E0;&#x4E3A;&#x5F88;&#x591A;&#x65F6;&#x5019;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5B9E;&#x73B0;&#x9002;&#x5F53;&#x7684;&#x540C;&#x6B65;&#xFF0C;&#x5C31;&#x50CF;&#x4E0B;&#x9762;&#x4ECB;&#x7ECD;&#x7684;&#x90A3;&#x6837;&#x3002;&#x5C3D;&#x7BA1;&#x5B9E;&#x73B0;&#x9002;&#x5F53;&#x7684;&#x540C;&#x6B65;&#x5F88;&#x56F0;&#x96BE;&#xFF0C;&#x800C;&#x4E14;&#x7A81;&#x53D8;&#x70B9;&#x8D8A;&#x591A;&#xFF0C;&#x540C;&#x6B65;&#x5C31;&#x8D8A;&#x56F0;&#x96BE;&#x3002;&#x6240;&#x4EE5;&#x9650;&#x5236;&#x53EF;&#x53D8;&#x6027;&#x5C31;&#x5F88;&#x91CD;&#x8981;&#x3002;</p>
<pre><code class="lang-kotlin"> <span class="hljs-variable"><span class="hljs-keyword">val</span> lock</span> = Any()
 <span class="hljs-variable"><span class="hljs-keyword">var</span> num</span> = <span class="hljs-number">0</span>
 <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.1000</span>) {
    thread {
        Thread.sleep(<span class="hljs-number">10</span>)
        synchronized(lock) {
            num += <span class="hljs-number">1</span>
        }
    }
 }
 Thread.sleep(<span class="hljs-number">1000</span>)
 print(num) <span class="hljs-comment">// 1000</span>
</code></pre>
<p>The drawbacks of mutability are so numerous that there are languages that do not allow state mutation at all. These are purely functional languages. One well-known example is Haskell. Such languages are rarely used for mainstream development though, since it&#x2019;s very hard to do programming with so limited mutability. Mutating state is a very useful way to represent the state of real-world systems. I recommend using mutability, but do it sparingly and wisely decide where our mutating points should be. The good news is that Kotlin supports limiting mutability well.</p>
<p>&#x53EF;&#x53D8;&#x6027;&#x7684;&#x7F3A;&#x70B9;&#x662F;&#x5982;&#x6B64;&#x4E4B;&#x591A;&#xFF0C;&#x4EE5;&#x81F3;&#x4E8E;&#x6709;&#x4E9B;&#x8BED;&#x8A00;&#x6839;&#x672C;&#x4E0D;&#x5141;&#x8BB8;&#x72B6;&#x6001;&#x7A81;&#x53D8;&#x3002;&#x8FD9;&#x4E9B;&#x90FD;&#x662F;&#x7EAF;&#x7CB9;&#x7684;&#x51FD;&#x6570;&#x5F0F;&#x8BED;&#x8A00;&#x3002;Haskell&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x8457;&#x540D;&#x7684;&#x4F8B;&#x5B50;&#x3002;&#x5C3D;&#x7BA1;&#x5982;&#x6B64;&#xFF0C;&#x8FD9;&#x79CD;&#x8BED;&#x8A00;&#x5F88;&#x5C11;&#x7528;&#x4E8E;&#x4E3B;&#x6D41;&#x5F00;&#x53D1;&#xFF0C;&#x56E0;&#x4E3A;&#x4F7F;&#x7528;&#x5982;&#x6B64;&#x6709;&#x9650;&#x7684;&#x53EF;&#x53D8;&#x6027;&#x5F88;&#x96BE;&#x8FDB;&#x884C;&#x7F16;&#x7A0B;&#x3002;&#x7A81;&#x53D8;&#x72B6;&#x6001;&#x662F;&#x8868;&#x793A;&#x771F;&#x5B9E;&#x4E16;&#x754C;&#x7CFB;&#x7EDF;&#x72B6;&#x6001;&#x7684;&#x4E00;&#x79CD;&#x975E;&#x5E38;&#x6709;&#x7528;&#x7684;&#x65B9;&#x6CD5;&#x3002;&#x6211;&#x5EFA;&#x8BAE;&#x4F7F;&#x7528;&#x53EF;&#x53D8;&#x6027;&#xFF0C;&#x4F46;&#x8981;&#x8C28;&#x614E;&#x4F7F;&#x7528;&#xFF0C;&#x5E76;&#x660E;&#x667A;&#x5730;&#x51B3;&#x5B9A;&#x6211;&#x4EEC;&#x7684;&#x7A81;&#x53D8;&#x70B9;&#x5E94;&#x8BE5;&#x5728;&#x54EA;&#x91CC;&#x3002;&#x597D;&#x6D88;&#x606F;&#x662F;Kotlin&#x5F88;&#x597D;&#x5730;&#x652F;&#x6301;&#x9650;&#x5236;&#x53EF;&#x53D8;&#x6027;&#x3002;</p>
<h4 id="limiting-mutability-in-kotlin">Limiting mutability in Kotlin</h4>
<h4 id="&#x9650;&#x5236;kotlin&#x7684;&#x53EF;&#x53D8;&#x6027;">&#x9650;&#x5236;kotlin&#x7684;&#x53EF;&#x53D8;&#x6027;</h4>
<p>Kotlin is designed to support limiting mutability. It is easy to make immutable objects or to keep properties immutable. It is a result of many features and characteristics of this language, but the most important ones are:
Kotlin&#x88AB;&#x8BBE;&#x8BA1;&#x7528;&#x6765;&#x652F;&#x6301;&#x6709;&#x9650;&#x7684;&#x53EF;&#x53D8;&#x6027;&#x3002;&#x521B;&#x5EFA;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x6216;&#x4FDD;&#x6301;&#x5C5E;&#x6027;&#x4E0D;&#x53EF;&#x53D8;&#x662F;&#x5F88;&#x5BB9;&#x6613;&#x7684;&#x3002;&#x8FD9;&#x662F;&#x8BE5;&#x8BED;&#x8A00;&#x8BB8;&#x591A;&#x7279;&#x6027;&#x548C;&#x7279;&#x70B9;&#x7684;&#x7ED3;&#x679C;&#xFF0C;&#x4F46;&#x6700;&#x91CD;&#x8981;&#x7684;&#x662F;:</p>
<ul>
<li>Read-only properties val</li>
<li><p>&#x53EA;&#x8BFB;&#x5C5E;&#x6027;val</p>
</li>
<li><p>Separation between mutable and read-only collections</p>
</li>
<li><p>&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x548C;&#x53EA;&#x8BFB;&#x96C6;&#x5408;&#x4E4B;&#x95F4;&#x7684;&#x5206;&#x79BB;</p>
</li>
<li><p>copy in data classes</p>
</li>
<li>&#x5728;&#x6570;&#x636E;&#x7C7B;&#x4E2D;&#x590D;&#x5236;</li>
</ul>
<p>Let&#x2019;s discuss them one by one.
&#x8BA9;&#x6211;&#x4EEC;&#x4E00;&#x4E2A;&#x4E2A;&#x7684;&#x8BA8;&#x8BBA;&#x4ED6;&#x4EEC;</p>
<h4 id="read-only-properties-val">Read-only properties val</h4>
<p>In Kotlin we can make each property read-only val (like value) or read-write var (like variable). Read-only properties val do not allow setting:
&#x5728;Kotlin&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x5C06;&#x6BCF;&#x4E2A;&#x5C5E;&#x6027;&#x8BBE;&#x7F6E;&#x4E3A;&#x53EA;&#x8BFB;val(&#x7C7B;&#x4F3C;&#x503C;)&#x6216;&#x8BFB;&#x5199;var(&#x7C7B;&#x4F3C;&#x53D8;&#x91CF;)&#x3002;&#x53EA;&#x8BFB;&#x5C5E;&#x6027;val&#x4E0D;&#x5141;&#x8BB8;&#x8BBE;&#x7F6E;:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> a</span> = <span class="hljs-number">10</span>
a = <span class="hljs-number">20</span> <span class="hljs-comment">// ERROR</span>
</code></pre>
<p>Notice though that read-only properties are not necessarily immutable nor final. A read-only property can hold a mutable object:
&#x4E0D;&#x8FC7;&#x8BF7;&#x6CE8;&#x610F;&#xFF0C;&#x53EA;&#x8BFB;&#x5C5E;&#x6027;&#x4E0D;&#x4E00;&#x5B9A;&#x662F;&#x4E0D;&#x53EF;&#x53D8;&#x7684;&#xFF0C;&#x4E5F;&#x4E0D;&#x4E00;&#x5B9A;&#x662F;&#x6700;&#x7EC8;&#x7684;&#x3002;&#x53EA;&#x8BFB;&#x5C5E;&#x6027;&#x53EF;&#x4EE5;&#x4FDD;&#x5B58;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> list</span> = mutableListOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) 
list.add(<span class="hljs-number">4</span>)

print(list) <span class="hljs-comment">// [1, 2, 3, 4]</span>
</code></pre>
<p>A read-only property can also be defined using a custom getter that might depend on another property:
&#x53EA;&#x8BFB;&#x5C5E;&#x6027;&#x4E5F;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x53EF;&#x80FD;&#x4F9D;&#x8D56;&#x4E8E;&#x53E6;&#x4E00;&#x4E2A;&#x5C5E;&#x6027;&#x7684;&#x81EA;&#x5B9A;&#x4E49;getter&#x6765;&#x5B9A;&#x4E49;:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">var</span> name</span>: String = <span class="hljs-string">&quot;Marcin&quot;</span>
<span class="hljs-variable"><span class="hljs-keyword">var</span> surname</span>: String = <span class="hljs-string">&quot;Moska&#x142;a&quot;</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> fullName 
    get()</span> = <span class="hljs-string">&quot;$name $surname&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> {</span>
   println(fullName) <span class="hljs-comment">// Marcin Moska&#x142;a</span>
   name = <span class="hljs-string">&quot;Maja&quot;</span>
   println(fullName) <span class="hljs-comment">// Maja Moska&#x142;a</span>
}
</code></pre>
<p>Notice that it is possible because when we define a custom getter, it will be called every time we ask for the value.
&#x6CE8;&#x610F;&#xFF0C;&#x8FD9;&#x662F;&#x53EF;&#x80FD;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x5F53;&#x6211;&#x4EEC;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A;&#x81EA;&#x5B9A;&#x4E49;getter&#x65F6;&#xFF0C;&#x6BCF;&#x6B21;&#x6211;&#x4EEC;&#x8BF7;&#x6C42;&#x503C;&#x65F6;&#xFF0C;&#x5B83;&#x90FD;&#x4F1A;&#x88AB;&#x8C03;&#x7528;&#x3002;</p>
<pre><code class="lang-kotlin"> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span>: <span class="hljs-keyword">Int</span> {</span>
    print(<span class="hljs-string">&quot;Calculating... &quot;</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>
 }

 <span class="hljs-variable"><span class="hljs-keyword">val</span> fizz</span> = calculate() <span class="hljs-comment">// Calculating...</span>
 <span class="hljs-variable"><span class="hljs-keyword">val</span> buzz
    get()</span> = calculate()

 <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> {</span>
    print(fizz) <span class="hljs-comment">// 42</span>
    print(fizz) <span class="hljs-comment">// 42</span>
    print(buzz) <span class="hljs-comment">// Calculating... 42</span>
    print(buzz) <span class="hljs-comment">// Calculating... 42</span>
 }
</code></pre>
<p>This trait, that properties in Kotlin are encapsulated by default and they can have custom accessors (getters and setters) is very important in Kotlin because it gives us flexibility when we change or define our API. It will be described in detail in Item 16: Properties should represent state, not behavior. The core idea though is that val do not offer mutation points because it is only a getter under the hood when var is both getter and setter. That&#x2019;s why we can override val with var:</p>
<p>Kotlin&#x4E2D;&#x7684;&#x5C5E;&#x6027;&#x662F;&#x9ED8;&#x8BA4;&#x5C01;&#x88C5;&#x7684;&#xFF0C;&#x5B83;&#x4EEC;&#x53EF;&#x4EE5;&#x6709;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x8BBF;&#x95EE;&#x5668;(getter&#x548C;setter)&#xFF0C;&#x8FD9;&#x5728;Kotlin&#x4E2D;&#x975E;&#x5E38;&#x91CD;&#x8981;&#xFF0C;&#x56E0;&#x4E3A;&#x5F53;&#x6211;&#x4EEC;&#x66F4;&#x6539;&#x6216;&#x5B9A;&#x4E49;API&#x65F6;&#xFF0C;&#x5B83;&#x7ED9;&#x4E86;&#x6211;&#x4EEC;&#x7075;&#x6D3B;&#x6027;&#x3002;&#x8FD9;&#x5C06;&#x5728;&#x7B2C;16&#x9879;&#x4E2D;&#x8BE6;&#x7EC6;&#x63CF;&#x8FF0;:&#x5C5E;&#x6027;&#x5E94;&#x8BE5;&#x8868;&#x793A;&#x72B6;&#x6001;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x884C;&#x4E3A;&#x3002;&#x4F46;&#x5176;&#x6838;&#x5FC3;&#x601D;&#x60F3;&#x662F;val&#x4E0D;&#x63D0;&#x4F9B;&#x7A81;&#x53D8;&#x70B9;&#xFF0C;&#x56E0;&#x4E3A;&#x5F53;var&#x540C;&#x65F6;&#x662F;getter&#x548C;setter&#x65F6;&#xFF0C;&#x5B83;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x5E95;&#x5C42;&#x7684;getter&#x3002;&#x8FD9;&#x5C31;&#x662F;&#x4E3A;&#x4EC0;&#x4E48;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x7528;var&#x8986;&#x76D6;val:</p>
<pre><code class="lang-kotlin">interface Element {
   <span class="hljs-variable"><span class="hljs-keyword">val</span> active</span>: <span class="hljs-keyword">Boolean</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActualElement</span>: <span class="hljs-type">Element {</span></span>
   <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">var</span> active</span>: <span class="hljs-keyword">Boolean</span> = <span class="hljs-literal">false</span>
}
</code></pre>
<p>Values of read-only properties val can change, but such properties do not offer a mutation point which is the main source of problems when we need to synchronize or reason about a program. This is why we generally prefer val over var.</p>
<p>Although remember that val doesn&#x2019;t mean immutable. It can be defined by getter or delegate. This fact gives us more freedom to change. Though when we don&#x2019;t need that, final properties should be preferred. It is easier to reason about them as they have the state stated next to their definition. They are also better supported in Kotlin. For instance, they can be smart-casted:</p>
<p>&#x53EA;&#x8BFB;&#x5C5E;&#x6027;val&#x7684;&#x503C;&#x53EF;&#x4EE5;&#x6539;&#x53D8;&#xFF0C;&#x4F46;&#x8FD9;&#x6837;&#x7684;&#x5C5E;&#x6027;&#x4E0D;&#x63D0;&#x4F9B;&#x7A81;&#x53D8;&#x70B9;&#xFF0C;&#x8FD9;&#x662F;&#x5F53;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x540C;&#x6B65;&#x6216;&#x63A8;&#x7406;&#x7A0B;&#x5E8F;&#x65F6;&#x95EE;&#x9898;&#x7684;&#x4E3B;&#x8981;&#x6765;&#x6E90;&#x3002;&#x8FD9;&#x5C31;&#x662F;&#x4E3A;&#x4EC0;&#x4E48;&#x6211;&#x4EEC;&#x901A;&#x5E38;&#x66F4;&#x559C;&#x6B22;val&#x800C;&#x4E0D;&#x662F;var&#x3002;
&#x8BB0;&#x4F4F;val&#x5E76;&#x4E0D;&#x610F;&#x5473;&#x7740;&#x4E0D;&#x53EF;&#x53D8;&#x3002;&#x5B83;&#x53EF;&#x4EE5;&#x7531;getter&#x6216;delegate&#x5B9A;&#x4E49;&#x3002;&#x8FD9;&#x4E00;&#x4E8B;&#x5B9E;&#x7ED9;&#x4E86;&#x6211;&#x4EEC;&#x66F4;&#x591A;&#x7684;&#x6539;&#x53D8;&#x7684;&#x81EA;&#x7531;&#x3002;&#x5C3D;&#x7BA1;&#x5F53;&#x6211;&#x4EEC;&#x4E0D;&#x9700;&#x8981;&#x5B83;&#x65F6;&#xFF0C;&#x6700;&#x7EC8;&#x5C5E;&#x6027;&#x5E94;&#x8BE5;&#x662F;&#x9996;&#x9009;&#x3002;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x7684;&#x5B9A;&#x4E49;&#x65C1;&#x8FB9;&#x6807;&#x660E;&#x4E86;&#x72B6;&#x6001;&#xFF0C;&#x6240;&#x4EE5;&#x66F4;&#x5BB9;&#x6613;&#x5BF9;&#x5B83;&#x4EEC;&#x8FDB;&#x884C;&#x63A8;&#x7406;&#x3002;&#x4ED6;&#x4EEC;&#x5728;Kotlin&#x4E5F;&#x5F97;&#x5230;&#x4E86;&#x66F4;&#x597D;&#x7684;&#x652F;&#x6301;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x4ED6;&#x4EEC;&#x53EF;&#x4EE5;</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String? = <span class="hljs-string">&quot;M&#xE1;rton&quot;</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> surname</span>: String = <span class="hljs-string">&quot;Braun&quot;</span>

<span class="hljs-variable"><span class="hljs-keyword">val</span> fullName</span>: String?
   <span class="hljs-keyword">get</span>() = name?.let { <span class="hljs-string">&quot;$it $surname&quot;</span> }

<span class="hljs-variable"><span class="hljs-keyword">val</span> fullName2</span>: String? = name?.let { <span class="hljs-string">&quot;$it $surname&quot;</span> }

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> {</span>
   <span class="hljs-keyword">if</span> (fullName != <span class="hljs-literal">null</span>) {
       println(fullName.length) <span class="hljs-comment">// ERROR</span>
   }

   <span class="hljs-keyword">if</span> (fullName2 != <span class="hljs-literal">null</span>) {
       println(fullName2.length) <span class="hljs-comment">// M&#xE1;rton Braun</span>
   }
}
</code></pre>
<p>Smart cast is impossible for fullName because it is defined using getter, so it might give a different value during check and different later during use (for instance, if some other thread would set name). Non-local properties can be smart-casted only when they are final and do not have custom getter.</p>
<p>fullName&#x7684;&#x667A;&#x80FD;&#x8F6C;&#x6362;&#x662F;&#x4E0D;&#x53EF;&#x80FD;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x662F;&#x7528;getter&#x5B9A;&#x4E49;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x5B83;&#x53EF;&#x80FD;&#x5728;&#x68C0;&#x67E5;&#x65F6;&#x7ED9;&#x51FA;&#x4E00;&#x4E2A;&#x4E0D;&#x540C;&#x7684;&#x503C;&#xFF0C;&#x5728;&#x4EE5;&#x540E;&#x7684;&#x4F7F;&#x7528;&#x4E2D;&#x4E5F;&#x4F1A;&#x4E0D;&#x540C;(&#x4F8B;&#x5982;&#xFF0C;&#x5982;&#x679C;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x8BBE;&#x7F6E;&#x4E86;name)&#x3002;&#x975E;&#x672C;&#x5730;&#x5C5E;&#x6027;&#x53EA;&#x6709;&#x5728;&#x5B83;&#x4EEC;&#x662F;final&#x4E14;&#x6CA1;&#x6709;&#x81EA;&#x5B9A;&#x4E49;getter&#x65F6;&#x624D;&#x80FD;&#x88AB;&#x667A;&#x80FD;&#x5F3A;&#x5236;&#x8F6C;&#x6362;&#x3002;</p>
<h4 id="separation-between-mutable-and-read-only-collections">Separation between mutable and read-only collections</h4>
<h4 id="&#x53EF;&#x53D8;&#x548C;&#x53EA;&#x8BFB;&#x96C6;&#x5408;&#x7684;&#x5206;&#x79BB;">&#x53EF;&#x53D8;&#x548C;&#x53EA;&#x8BFB;&#x96C6;&#x5408;&#x7684;&#x5206;&#x79BB;</h4>
<p>Similarly, as Kotlin separates read-write and read-only properties, Kotlin separates read-write and read-only collections. This is achieved thanks to the way the hierarchy of collections was designed. Take a look at the diagram presenting collections hierarchy in Kotlin. On the left side, you can see the Iterable, Collection, Set, and List interfaces that are read-only. This means that they do not have any methods that would allow modification. On the right side, you can see the MutableIterable, MutableCollection, MutableSet, and MutableList interfaces that represent mutable collections. Notice that each mutable interface extends the corresponding read-only interface, and adds methods that allow mutation. This is similar to how properties work. A read-only property means just a getter, while a read-write property means both a getter and a setter.</p>
<p>&#x7C7B;&#x4F3C;&#x5730;&#xFF0C;Kotlin&#x5C06;&#x8BFB;&#x5199;&#x548C;&#x53EA;&#x8BFB;&#x5C5E;&#x6027;&#x5206;&#x5F00;&#xFF0C;Kotlin&#x4E5F;&#x5C06;&#x8BFB;&#x5199;&#x548C;&#x53EA;&#x8BFB;&#x96C6;&#x5408;&#x5206;&#x5F00;&#x3002;&#x8FD9;&#x8981;&#x5F52;&#x529F;&#x4E8E;&#x96C6;&#x5408;&#x5C42;&#x6B21;&#x7ED3;&#x6784;&#x7684;&#x8BBE;&#x8BA1;&#x65B9;&#x6CD5;&#x3002;&#x770B;&#x4E00;&#x4E0B;&#x5728;Kotlin&#x4E2D;&#x5C55;&#x793A;&#x96C6;&#x5408;&#x5C42;&#x6B21;&#x7ED3;&#x6784;&#x7684;&#x56FE;&#x3002;&#x60A8;&#x53EF;&#x4EE5;&#x770B;&#x5230;Iterable&#x3001;Collection&#x3001;Set&#x548C;List&#x63A5;&#x53E3;&#xFF0C;&#x5B83;&#x4EEC;&#x662F;&#x53EA;&#x8BFB;&#x7684;&#x3002;&#x8FD9;&#x610F;&#x5473;&#x7740;&#x5B83;&#x4EEC;&#x6CA1;&#x6709;&#x4EFB;&#x4F55;&#x5141;&#x8BB8;&#x4FEE;&#x6539;&#x7684;&#x65B9;&#x6CD5;&#x3002;&#x5728;&#x53F3;&#x4FA7;&#xFF0C;&#x60A8;&#x53EF;&#x4EE5;&#x770B;&#x5230;MutableIterable&#x3001;MutableCollection&#x3001;MutableSet&#x548C;MutableList&#x63A5;&#x53E3;&#xFF0C;&#x5B83;&#x4EEC;&#x8868;&#x793A;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x3002;</p>
<p><img src="../../assets/chapter1/chapter1-1.png" alt="The hierarchy of collection interfaces in Kotlin and actual objects that can be used on Kotlin/JVM. On the left side interfaces are read-only. On the right side collections and interfaces are mutable."></p>
<p>Read-only collections are not necessarily immutable. Very often they are mutable, but they cannot be mutated because they are hidden behind read-only interfaces. For instance, the Iterable<t>.map and Iterable<t>.filter functions return ArrayList, which is a mutable list, as a List, which is a read-only interface. In the below snippet you can see a simplified implementation of Iterable<t>.map from stdlib.</t></t></t></p>
<p>&#x53EA;&#x8BFB;&#x96C6;&#x5408;&#x4E0D;&#x4E00;&#x5B9A;&#x662F;&#x4E0D;&#x53EF;&#x53D8;&#x7684;&#x3002;&#x5B83;&#x4EEC;&#x901A;&#x5E38;&#x662F;&#x53EF;&#x53D8;&#x7684;&#xFF0C;&#x4F46;&#x4E0D;&#x80FD;&#x88AB;&#x6539;&#x53D8;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x9690;&#x85CF;&#x5728;&#x53EA;&#x8BFB;&#x63A5;&#x53E3;&#x540E;&#x9762;&#x3002;&#x4F8B;&#x5982;&#xFF0C;Iterable<t>&#x3002;&#x5730;&#x56FE;&#x548C;Iterable &lt; T &gt;&#x3002;filter&#x51FD;&#x6570;&#x8FD4;&#x56DE;ArrayList&#xFF0C;&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x53EF;&#x53D8;&#x5217;&#x8868;&#xFF0C;&#x4F5C;&#x4E3A;list&#xFF0C;&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x53EA;&#x8BFB;&#x63A5;&#x53E3;&#x3002;&#x5728;&#x4E0B;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x7247;&#x6BB5;&#x4E2D;&#xFF0C;&#x60A8;&#x53EF;&#x4EE5;&#x770B;&#x5230;Iterable<t>&#x7684;&#x7B80;&#x5316;&#x5B9E;&#x73B0;&#x3002;&#x4ECE;stdlib&#x5730;&#x56FE;&#x3002;</t></t></p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(
   transformation: <span class="hljs-type">(T</span>)</span> -&gt; R</span>
): List<span class="hljs-type">&lt;R&gt;</span> {
   <span class="hljs-variable"><span class="hljs-keyword">val</span> list</span> = ArrayList<span class="hljs-type">&lt;R&gt;</span>()
   <span class="hljs-keyword">for</span> (elem <span class="hljs-keyword">in</span> this) {
       list.add(transformation(elem))
   }
   <span class="hljs-keyword">return</span> list
}
</code></pre>
<p>The design choice to make these collection interfaces read-only instead of truly immutable is very important. It gives us much more freedom. Under the hood, any actual collection can be returned as long as it satisfies the interface. Therefore, we can use platform-specific collections.</p>
<p>&#x5C06;&#x8FD9;&#x4E9B;&#x96C6;&#x5408;&#x63A5;&#x53E3;&#x53D8;&#x4E3A;&#x53EA;&#x8BFB;&#x800C;&#x4E0D;&#x662F;&#x771F;&#x6B63;&#x4E0D;&#x53EF;&#x53D8;&#x7684;&#x8BBE;&#x8BA1;&#x9009;&#x62E9;&#x662F;&#x975E;&#x5E38;&#x91CD;&#x8981;&#x7684;&#x3002;&#x5B83;&#x7ED9;&#x4E86;&#x6211;&#x4EEC;&#x66F4;&#x591A;&#x7684;&#x81EA;&#x7531;&#x3002;&#x5728;&#x5F15;&#x64CE;&#x76D6;&#x4E0B;&#xFF0C;&#x53EA;&#x8981;&#x6EE1;&#x8DB3;&#x63A5;&#x53E3;&#xFF0C;&#x4EFB;&#x4F55;&#x5B9E;&#x9645;&#x7684;&#x96C6;&#x5408;&#x90FD;&#x53EF;&#x4EE5;&#x8FD4;&#x56DE;&#x3002;&#x56E0;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x7279;&#x5B9A;&#x4E8E;&#x5E73;&#x53F0;&#x7684;&#x96C6;&#x5408;&#x3002;</p>
<p>The safety of this approach is close to the one achieved from having immutable collections. The only risk is when a developer tries to &#x201C;hack the system&#x201D; and performs down-casting. This is something that should never be allowed in Kotlin projects. We should be able to trust that when we return a list as read-only, it will be used only to read it. This is part of the contract. More about it on Part 2 of this book.</p>
<p>&#x8FD9;&#x79CD;&#x65B9;&#x6CD5;&#x7684;&#x5B89;&#x5168;&#x6027;&#x63A5;&#x8FD1;&#x4E8E;&#x4F7F;&#x7528;&#x4E0D;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x6240;&#x83B7;&#x5F97;&#x7684;&#x5B89;&#x5168;&#x6027;&#x3002;&#x552F;&#x4E00;&#x7684;&#x98CE;&#x9669;&#x662F;&#x5F53;&#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x8BD5;&#x56FE;&#x201C;&#x9ED1;&#x8FDB;&#x7CFB;&#x7EDF;&#x201D;&#x5E76;&#x6267;&#x884C;&#x5411;&#x4E0B;casting&#x65F6;&#x3002;&#x8FD9;&#x5728;Kotlin&#x9879;&#x76EE;&#x4E2D;&#x662F;&#x7EDD;&#x5BF9;&#x4E0D;&#x5141;&#x8BB8;&#x7684;&#x3002;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x80FD;&#x591F;&#x76F8;&#x4FE1;&#xFF0C;&#x5F53;&#x6211;&#x4EEC;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x53EA;&#x8BFB;&#x5217;&#x8868;&#x65F6;&#xFF0C;&#x5B83;&#x5C06;&#x53EA;&#x7528;&#x4E8E;&#x8BFB;&#x53D6;&#x5B83;&#x3002;&#x8FD9;&#x662F;&#x5408;&#x540C;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x3002;&#x5173;&#x4E8E;&#x5B83;&#x7684;&#x66F4;&#x591A;&#x5185;&#x5BB9;&#xFF0C;&#x8BF7;&#x53C2;&#x9605;&#x672C;&#x4E66;&#x7684;&#x7B2C;&#x4E8C;&#x90E8;&#x5206;&#x3002;</p>
<p>Down-casting collections is not only breaking their contract and depending on implementation instead of abstraction as we should, but it is also insecure and can lead to surprising consequences. Take a look at this code:</p>
<p>&#x96C6;&#x5408;&#x5411;&#x4E0B;&#x8F6C;&#x6362;&#x4E0D;&#x4EC5;&#x7834;&#x574F;&#x4E86;&#x5B83;&#x4EEC;&#x7684;&#x89C4;&#x5219;&#xFF0C;&#x800C;&#x4E14;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x4F9D;&#x8D56;&#x4E8E;&#x5B9E;&#x73B0;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x4F9D;&#x8D56;&#x62BD;&#x8C61;&#xFF0C;&#x800C;&#x4E14;&#x5B83;&#x4E5F;&#x4E0D;&#x5B89;&#x5168;&#xFF0C;&#x5E76;&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x4EE4;&#x4EBA;&#x60CA;&#x8BB6;&#x7684;&#x540E;&#x679C;&#x3002;&#x770B;&#x770B;&#x8FD9;&#x6BB5;&#x4EE3;&#x7801;:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> list</span> = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)

<span class="hljs-comment">// DON&#x2019;T DO THIS!</span>
<span class="hljs-keyword">if</span> (list <span class="hljs-keyword">is</span> MutableList) {
   list.add(<span class="hljs-number">4</span>)
}
</code></pre>
<p>The result of this operation is platform-specific. On the JVM listOf returns an instance of Arrays.ArrayList that implements Java List interface. This Java List interface has methods like add or set, and so it translates to the Kotlin MutableList interface. However, Arrays.ArrayList does not implement some of those operations. This is why the result of the above code is the following:</p>
<p>&#x6B64;&#x64CD;&#x4F5C;&#x7684;&#x7ED3;&#x679C;&#x662F;&#x7279;&#x5B9A;&#x4E8E;&#x5E73;&#x53F0;&#x7684;&#x3002;&#x5728;JVM&#x7684;listOf&#x4E2D;&#x8FD4;&#x56DE;array&#x7684;&#x4E00;&#x4E2A;&#x5B9E;&#x4F8B;&#x3002;&#x5B9E;&#x73B0;Java List&#x63A5;&#x53E3;&#x7684;&#x6570;&#x7EC4;&#x5217;&#x8868;&#x3002;&#x8FD9;&#x4E2A;Java List&#x63A5;&#x53E3;&#x6709;&#x6DFB;&#x52A0;&#x6216;&#x8BBE;&#x7F6E;&#x7B49;&#x65B9;&#x6CD5;&#xFF0C;&#x56E0;&#x6B64;&#x5B83;&#x8F6C;&#x6362;&#x4E3A;Kotlin MutableList&#x63A5;&#x53E3;&#x3002;&#x7136;&#x800C;,&#x6570;&#x7EC4;&#x3002;ArrayList&#x6CA1;&#x6709;&#x5B9E;&#x73B0;&#x5176;&#x4E2D;&#x7684;&#x4E00;&#x4E9B;&#x64CD;&#x4F5C;&#x3002;&#x8FD9;&#x5C31;&#x662F;&#x4E3A;&#x4EC0;&#x4E48;&#x4E0A;&#x9762;&#x4EE3;&#x7801;&#x7684;&#x7ED3;&#x679C;&#x5982;&#x4E0B;:</p>
<pre><code class="lang-kotlin">Exception <span class="hljs-keyword">in</span> thread &#x201C;main&#x201D; java.lang.UnsupportedOperationException
at java.util.AbstractList.add(AbstractList.java:<span class="hljs-number">148</span>)
at java.util.AbstractList.add(AbstractList.java:<span class="hljs-number">108</span>)
</code></pre>
<p>Though there is no guarantee how this will behave in a year from now. Underlying collections might change. They might be replaced with truly immutable collections implemented in Kotlin and not implementing MutableList at all. Nothing is guaranteed. This is why down-casting read-only collections to mutable should never take place in Kotlin. If you need to change from read-only to mutable, you should use List.toMutableList function, which creates a copy that you can then modify:</p>
<p>&#x867D;&#x7136;&#x4E0D;&#x80FD;&#x4FDD;&#x8BC1;&#x4E00;&#x5E74;&#x540E;&#x66F4;&#x65B0;&#x4EC0;&#x4E48;&#x3002;&#x5E95;&#x5C42;&#x96C6;&#x5408;&#x53EF;&#x80FD;&#x4F1A;&#x6539;&#x53D8;&#x3002;&#x5B83;&#x4EEC;&#x53EF;&#x80FD;&#x88AB;Kotlin&#x4E2D;&#x5B9E;&#x73B0;&#x7684;&#x771F;&#x6B63;&#x7684;&#x4E0D;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x6240;&#x66FF;&#x4EE3;&#xFF0C;&#x800C;&#x6839;&#x672C;&#x4E0D;&#x5B9E;&#x73B0;MutableList&#x3002;&#x6CA1;&#x6709;&#x4EC0;&#x4E48;&#x662F;&#x53EF;&#x9760;&#x7684;&#x3002;&#x8FD9;&#x5C31;&#x662F;&#x4E3A;&#x4EC0;&#x4E48;&#x5728;Kotlin&#x4E2D;&#x4E0D;&#x5E94;&#x8BE5;&#x5C06;&#x53EA;&#x8BFB;&#x96C6;&#x5408;&#x5411;&#x4E0B;&#x8F6C;&#x6362;&#x4E3A;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x7684;&#x539F;&#x56E0;&#x3002;&#x5982;&#x679C;&#x9700;&#x8981;&#x4ECE;&#x53EA;&#x8BFB;&#x66F4;&#x6539;&#x4E3A;&#x53EF;&#x53D8;&#xFF0C;&#x5219;&#x5E94;&#x8BE5;&#x4F7F;&#x7528;List&#x3002;toMutableList&#x51FD;&#x6570;&#xFF0C;&#x5B83;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x4F60;&#x53EF;&#x4EE5;&#x4FEE;&#x6539;&#x7684;&#x526F;&#x672C;:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> list</span> = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-variable"><span class="hljs-keyword">val</span> mutableList</span> = list.toMutableList()
mutableList.add(<span class="hljs-number">4</span>)
</code></pre>
<p>This way does not break any contract, and it is also safer for us as we can feel safe that when we expose something as List it won&#x2019;t be modified from outside.</p>
<p>&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x4E0D;&#x4F1A;&#x7834;&#x574F;&#x4EFB;&#x4F55;&#x89C4;&#x5219;&#xFF0C;&#x800C;&#x4E14;&#x5BF9;&#x6211;&#x4EEC;&#x6765;&#x8BF4;&#x4E5F;&#x66F4;&#x5B89;&#x5168;&#xFF0C;&#x56E0;&#x4E3A;&#x5F53;&#x6211;&#x4EEC;&#x5C06;&#x67D0;&#x4E9B;&#x5185;&#x5BB9;&#x66B4;&#x9732;&#x4E3A;List&#x65F6;&#xFF0C;&#x5B83;&#x4E0D;&#x4F1A;&#x4ECE;&#x5916;&#x90E8;&#x88AB;&#x4FEE;&#x6539;&#x3002;</p>
<h4 id="copy-in-data-classes">Copy in data classes</h4>
<h4 id="&#x590D;&#x5236;&#x6570;&#x636E;&#x7C7B;">&#x590D;&#x5236;&#x6570;&#x636E;&#x7C7B;</h4>
<p>There are many reasons to prefer immutable objects - objects that do not change their internal state, like String or Int. In addition to the already named reasons why we generally prefer less mutability, immutable objects have their own advantages:</p>
<p>&#x4F7F;&#x7528;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;(&#x4E0D;&#x6539;&#x53D8;&#x5176;&#x5185;&#x90E8;&#x72B6;&#x6001;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;&#x5982;String&#x6216;Int)&#x6709;&#x5F88;&#x591A;&#x539F;&#x56E0;&#x3002;&#x9664;&#x4E86;&#x5DF2;&#x7ECF;&#x547D;&#x540D;&#x7684;&#x539F;&#x56E0;&#xFF0C;&#x6211;&#x4EEC;&#x901A;&#x5E38;&#x66F4;&#x559C;&#x6B22;&#x66F4;&#x5C11;&#x7684;&#x53EF;&#x53D8;&#x6027;&#xFF0C;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x6709;&#x5176;&#x81EA;&#x8EAB;&#x7684;&#x4F18;&#x52BF;:</p>
<ol>
<li>They are easier to reason about since their state stays the same once they are created.</li>
<li>&#x5B83;&#x4EEC;&#x66F4;&#x5BB9;&#x6613;&#x63A8;&#x7406;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x7684;&#x72B6;&#x6001;&#x5728;&#x521B;&#x5EFA;&#x540E;&#x4FDD;&#x6301;&#x4E0D;&#x53D8;&#x3002;//&#x63A8;&#x7406;&#x5565;&#x610F;&#x601D;&#x5462;</li>
<li>Immutability makes it easier to parallelize the program as there are no conflicts among shared objects.</li>
<li>&#x4E0D;&#x53EF;&#x53D8;&#x6027;&#x4F7F;&#x5F97;&#x4FDD;&#x8BC1;&#x5E76;&#x53D1;&#x5B89;&#x5168;&#x53D8;&#x5F97;&#x66F4;&#x5BB9;&#x6613;&#xFF0C;&#x56E0;&#x4E3A;&#x5171;&#x4EAB;&#x5BF9;&#x8C61;&#x4E4B;&#x95F4;&#x4E0D;&#x5B58;&#x5728;&#x51B2;&#x7A81;&#x3002;</li>
<li>References to immutable objects can be cached as they are not going to change.</li>
<li>&#x5BF9;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x7684;&#x5F15;&#x7528;&#x53EF;&#x4EE5;&#x88AB;&#x7F13;&#x5B58;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x4E0D;&#x4F1A;&#x6539;&#x53D8;&#x3002;</li>
<li>We do not need to make defensive copies on immutable objects. When we do copy immutable objects, we do not need to make it a deep copy.</li>
<li>&#x6211;&#x4EEC;&#x4E0D;&#x9700;&#x8981;&#x5BF9;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x8FDB;&#x884C;&#x9632;&#x5FA1;&#x6027;&#x590D;&#x5236;&#x3002;&#x5F53;&#x590D;&#x5236;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x5C06;&#x5176;&#x4F5C;&#x4E3A;&#x6DF1;&#x5EA6;&#x590D;&#x5236;&#x3002;</li>
<li>Immutable objects are the perfect material to construct other objects. Both mutable and immutable. We can still decide where mutability takes place, and it is easier to operate on immutable objects.</li>
<li>&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x662F;&#x6784;&#x9020;&#x5176;&#x4ED6;&#x5BF9;&#x8C61;&#x7684;&#x5B8C;&#x7F8E;&#x6750;&#x6599;&#x3002;&#x53EF;&#x53D8;&#x7684;&#x548C;&#x4E0D;&#x53EF;&#x53D8;&#x7684;&#x3002;&#x6211;&#x4EEC;&#x4ECD;&#x7136;&#x53EF;&#x4EE5;&#x51B3;&#x5B9A;&#x5728;&#x54EA;&#x91CC;&#x53D1;&#x751F;&#x53EF;&#x53D8;&#x6027;&#xFF0C;&#x800C;&#x4E14;&#x64CD;&#x4F5C;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x4E5F;&#x66F4;&#x5BB9;&#x6613;&#x3002;</li>
<li>We can add them to set or use them as keys in maps, in opposition to mutable objects that shouldn&#x2019;t be used this way. This is because both those collections use hash table under the hood in Kotlin/JVM, and when we modify elements already classified to a hash table, its classification might not be correct anymore and we won&#x2019;t be able to find it. This problem will be described in detail in Item 41: Respect the contract of hashCode. We have a similar issue when a collection is sorted.</li>
<li>&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x6DFB;&#x52A0;&#x5B83;&#x4EEC;&#x6765;&#x8BBE;&#x7F6E;&#x6216;&#x4F7F;&#x7528;&#x5B83;&#x4EEC;&#x4F5C;&#x4E3A;&#x6620;&#x5C04;&#x4E2D;&#x7684;&#x952E;&#xFF0C;&#x4E0E;&#x4E0D;&#x5E94;&#x8BE5;&#x8FD9;&#x6837;&#x4F7F;&#x7528;&#x7684;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x76F8;&#x53CD;&#x3002;&#x8FD9;&#x662F;&#x56E0;&#x4E3A;&#x8FD9;&#x4E24;&#x4E2A;&#x96C6;&#x5408;&#x5728;Kotlin/JVM&#x4E2D;&#x90FD;&#x4F7F;&#x7528;&#x54C8;&#x5E0C;&#x8868;&#xFF0C;&#x5F53;&#x6211;&#x4EEC;&#x4FEE;&#x6539;&#x5DF2;&#x7ECF;&#x5206;&#x7C7B;&#x5230;&#x54C8;&#x5E0C;&#x8868;&#x7684;&#x5143;&#x7D20;&#x65F6;&#xFF0C;&#x5B83;&#x7684;&#x5206;&#x7C7B;&#x53EF;&#x80FD;&#x4E0D;&#x518D;&#x6B63;&#x786E;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x65E0;&#x6CD5;&#x627E;&#x5230;&#x5B83;&#x3002;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;&#x5C06;&#x5728;Item 41: Respect the contract of hashCode&#x4E2D;&#x8BE6;&#x7EC6;&#x63CF;&#x8FF0;&#x3002;&#x5728;&#x5BF9;&#x96C6;&#x5408;&#x8FDB;&#x884C;&#x6392;&#x5E8F;&#x65F6;&#xFF0C;&#x6211;&#x4EEC;&#x4E5F;&#x4F1A;&#x9047;&#x5230;&#x7C7B;&#x4F3C;&#x7684;&#x95EE;&#x9898;&#x3002;</li>
</ol>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> names</span>: SortedSet<span class="hljs-type">&lt;FullName&gt;</span> = TreeSet()
<span class="hljs-variable"><span class="hljs-keyword">val</span> person</span> = FullName(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>)
names.add(person)
names.add(FullName(<span class="hljs-string">&quot;Jordan&quot;</span>, <span class="hljs-string">&quot;Hansen&quot;</span>))
names.add(FullName(<span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-string">&quot;Blanc&quot;</span>))

print(names) <span class="hljs-comment">// [AAA AAA, David Blanc, Jordan Hansen]</span>
print(person <span class="hljs-keyword">in</span> names) <span class="hljs-comment">// true</span>

person.name = <span class="hljs-string">&quot;ZZZ&quot;</span>
print(names) <span class="hljs-comment">// [ZZZ AAA, David Blanc, Jordan Hansen]</span>
print(person <span class="hljs-keyword">in</span> names) <span class="hljs-comment">// false&#x201D;</span>
</code></pre>
<p>At the last check, collection returned false even though that person is in this set. It couldn&#x2019;t be found because it is in an incorrect position.
&#x5728;&#x6700;&#x540E;&#x4E00;&#x6B21;&#x68C0;&#x67E5;&#x65F6;&#xFF0C;&#x96C6;&#x5408;&#x8FD4;&#x56DE;false&#xFF0C;&#x5373;&#x4F7F;&#x8BE5;&#x4EBA;&#x5728;&#x8FD9;&#x4E2A;&#x96C6;&#x5408;&#x4E2D;&#x3002;&#x627E;&#x4E0D;&#x5230;&#xFF0C;&#x56E0;&#x4E3A;&#x4F4D;&#x7F6E;&#x4E0D;&#x5BF9;&#x3002;</p>
<p>As you can see, mutable objects are more dangerous and less predictable. On the other hand, the biggest problem of immutable objects is that data sometimes needs to change. The solution is that the immutable objects should have methods that produce an object after some change. For instance, Int is immutable, and it has many methods like plus or minus that do not modify it but instead return a new Int after this operation. Iterable is read-only, and collection processing functions like map or filter do not modify it, but instead return a new collection. The same can be applied to our immutable objects. For instance, let&#x2019;s say that we have an immutable class User and we need to allow its surname to change. We can support it with a withSurname method that produces a copy with a particular property changed:</p>
<p>&#x6B63;&#x5982;&#x60A8;&#x6240;&#x770B;&#x5230;&#x7684;&#xFF0C;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x66F4;&#x5371;&#x9669;&#xFF0C;&#x66F4;&#x96BE;&#x4EE5;&#x9884;&#x6D4B;&#x3002;&#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x7684;&#x6700;&#x5927;&#x95EE;&#x9898;&#x662F;&#x6570;&#x636E;&#x6709;&#x65F6;&#x9700;&#x8981;&#x66F4;&#x6539;&#x3002;&#x89E3;&#x51B3;&#x65B9;&#x6848;&#x662F;&#xFF0C;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x5E94;&#x8BE5;&#x6709;&#x4E00;&#x4E9B;&#x65B9;&#x6CD5;&#xFF0C;&#x8FD9;&#x4E9B;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x5728;&#x4E00;&#x4E9B;&#x66F4;&#x6539;&#x4E4B;&#x540E;&#x751F;&#x6210;&#x5BF9;&#x8C61;&#x3002;&#x4F8B;&#x5982;&#xFF0C;Int&#x662F;&#x4E0D;&#x53EF;&#x53D8;&#x7684;&#xFF0C;&#x5B83;&#x6709;&#x8BB8;&#x591A;&#x65B9;&#x6CD5;&#xFF0C;&#x5982;&#x52A0;&#x53F7;&#x6216;&#x51CF;&#x53F7;&#xFF0C;&#x8FD9;&#x4E9B;&#x65B9;&#x6CD5;&#x4E0D;&#x4F1A;&#x4FEE;&#x6539;Int&#xFF0C;&#x800C;&#x662F;&#x5728;&#x6B64;&#x64CD;&#x4F5C;&#x540E;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x65B0;&#x7684;Int&#x3002;Iterable&#x662F;&#x53EA;&#x8BFB;&#x7684;&#xFF0C;&#x96C6;&#x5408;&#x5904;&#x7406;&#x51FD;&#x6570;&#x5982;map&#x6216;filter&#x4E0D;&#x4F1A;&#x4FEE;&#x6539;&#x5B83;&#xFF0C;&#x800C;&#x662F;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x96C6;&#x5408;&#x3002;&#x540C;&#x6837;&#x7684;&#x9053;&#x7406;&#x4E5F;&#x9002;&#x7528;&#x4E8E;&#x6211;&#x4EEC;&#x7684;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(
   <span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String,
   <span class="hljs-variable"><span class="hljs-keyword">val</span> surname</span>: String
) {
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">withSurname</span><span class="hljs-params">(surname: <span class="hljs-type">String</span>)</span> = <span class="hljs-title">User</span><span class="hljs-params">(name, surname)</span><span class="hljs-comment">//&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5168;&#x65B0;&#x7684;</span></span>
}

<span class="hljs-variable"><span class="hljs-keyword">var</span> user</span> = User(<span class="hljs-string">&quot;Maja&quot;</span>, <span class="hljs-string">&quot;Markiewicz&quot;</span>)
user = user.withSurname(<span class="hljs-string">&quot;Moska&#x142;a&quot;</span>)
print(user) <span class="hljs-comment">// User(name=Maja, surname=Moska&#x142;a)</span>
</code></pre>
<p>Writing such functions is possible, but also tedious if we need one for every property. Here comes the data modifier to the rescue. One of the methods it generates is copy. It creates a new instance where all primary constructor properties are the same as in the previous one by default. New values can be specified as well. copy together with other methods generated by data modifier are described in detail in Item 37: Use data modifier to represent a bundle of data. Here is a simple example showing how it works:</p>
<p>&#x7F16;&#x5199;&#x8FD9;&#x6837;&#x7684;&#x51FD;&#x6570;&#x662F;&#x53EF;&#x80FD;&#x7684;&#xFF0C;&#x4F46;&#x5982;&#x679C;&#x6BCF;&#x4E2A;&#x5C5E;&#x6027;&#x90FD;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x7F16;&#x5199;&#x8FD9;&#x6837;&#x7684;&#x51FD;&#x6570;&#x4E5F;&#x4F1A;&#x5F88;&#x7E41;&#x7410;&#x3002;&#x8FD9;&#x91CC;&#x662F;&#x6570;&#x636E;&#x4FEE;&#x9970;&#x7B26;&#x7684;&#x62EF;&#x6551;&#x3002;&#x5B83;&#x751F;&#x6210;&#x7684;&#x65B9;&#x6CD5;&#x4E4B;&#x4E00;&#x662F;&#x590D;&#x5236;&#x3002;&#x5B83;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x5B9E;&#x4F8B;&#xFF0C;&#x5176;&#x4E2D;&#x6240;&#x6709;&#x4E3B;&#x6784;&#x9020;&#x51FD;&#x6570;&#x5C5E;&#x6027;&#x9ED8;&#x8BA4;&#x4E0E;&#x524D;&#x4E00;&#x4E2A;&#x76F8;&#x540C;&#x3002;&#x4E5F;&#x53EF;&#x4EE5;&#x6307;&#x5B9A;&#x65B0;&#x7684;&#x503C;&#x3002;copy&#x4E0E;&#x6570;&#x636E;&#x4FEE;&#x9970;&#x7B26;&#x751F;&#x6210;&#x7684;&#x5176;&#x4ED6;&#x65B9;&#x6CD5;&#x4E00;&#x8D77;&#x5728;&#x7B2C;Item 37: Use data modifier to represent a bundle of data&#x4E2D;&#x8BE6;&#x7EC6;&#x63CF;&#x8FF0;&#x3002;&#x4E0B;&#x9762;&#x662F;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x4F8B;&#x5B50;&#xFF0C;&#x5C55;&#x793A;&#x4E86;&#x5B83;&#x662F;&#x5982;&#x4F55;&#x5DE5;&#x4F5C;&#x7684;:</p>
<pre><code class="lang-kotlin">data <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(
   <span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String,
   <span class="hljs-variable"><span class="hljs-keyword">val</span> surname</span>: String
)

<span class="hljs-variable"><span class="hljs-keyword">var</span> user</span> = User(<span class="hljs-string">&quot;Maja&quot;</span>, <span class="hljs-string">&quot;Markiewicz&quot;</span>)
user = user.copy(surname = <span class="hljs-string">&quot;Moska&#x142;a&quot;</span>)
print(user) <span class="hljs-comment">// User(name=Maja, surname=Moska&#x142;a)</span>
</code></pre>
<p>This is an elegant and universal solution that supports making data model classes immutable. Surely, this way is less efficient than just using a mutable object instead, but it has all described advantages of immutable objects and should be preferred by default.</p>
<p>&#x8FD9;&#x662F;&#x4E00;&#x79CD;&#x4F18;&#x96C5;&#x800C;&#x901A;&#x7528;&#x7684;&#x89E3;&#x51B3;&#x65B9;&#x6848;&#xFF0C;&#x5B83;&#x652F;&#x6301;&#x4F7F;&#x6570;&#x636E;&#x6A21;&#x578B;&#x7C7B;&#x4E0D;&#x53EF;&#x53D8;&#x3002;&#x5F53;&#x7136;&#xFF0C;&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x6BD4;&#x4EC5;&#x4EC5;&#x4F7F;&#x7528;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x7684;&#x6548;&#x7387;&#x8981;&#x4F4E;&#xFF0C;&#x4F46;&#x5B83;&#x5177;&#x6709;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x6240;&#x63CF;&#x8FF0;&#x7684;&#x6240;&#x6709;&#x4F18;&#x70B9;&#xFF0C;&#x9ED8;&#x8BA4;&#x60C5;&#x51B5;&#x4E0B;&#x5E94;&#x8BE5;&#x662F;&#x9996;&#x9009;&#x3002;</p>
<h4 id="different-kinds-of-mutation-points">Different kinds of mutation points</h4>
<h4 id="&#x4E24;&#x79CD;&#x7C7B;&#x578B;&#x7684;&#x4E0D;&#x540C;&#x70B9;">&#x4E24;&#x79CD;&#x7C7B;&#x578B;&#x7684;&#x4E0D;&#x540C;&#x70B9;</h4>
<p>Let&#x2019;s say that we need to represent a mutating list. There are two ways we can achieve that. Either by using a mutable collection or by using read-write property var:
&#x5047;&#x8BBE;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8868;&#x793A;&#x4E00;&#x4E2A;&#x53D8;&#x5F02;&#x5217;&#x8868;&#x3002;&#x6709;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x5B9E;&#x73B0;&#x8FD9;&#x4E00;&#x76EE;&#x6807;&#x3002;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x53EF;&#x8BFB;&#x5199;&#x5C5E;&#x6027;var:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> list1</span>: MutableList<span class="hljs-type">&lt;Int&gt;</span> = mutableListOf() 
<span class="hljs-variable"><span class="hljs-keyword">var</span> list2</span>: List<span class="hljs-type">&lt;Int&gt;</span> = listOf()
</code></pre>
<p>Both properties can be modified, but in different ways:
&#x4E24;&#x79CD;&#x5C5E;&#x6027;&#x90FD;&#x53EF;&#x4EE5;&#x88AB;&#x4FEE;&#x6539;&#xFF0C;&#x7528;&#x4E0D;&#x540C;&#x7684;&#x65B9;&#x5F0F;</p>
<pre><code class="lang-kotlin">list1.add(<span class="hljs-number">1</span>) 
list2 = list2 + <span class="hljs-number">1</span>
</code></pre>
<p>Both of these ways can be replaced with the plus-assign operator as well, but each of them is translated into a different behavior:
&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x90FD;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x52A0;&#x53F7;&#x64CD;&#x4F5C;&#x7B26;&#xFF0C;&#x4F46;&#x662F;&#x5176;&#x672C;&#x8D28;&#x884C;&#x4E3A;&#x662F;&#x4E0D;&#x4E00;&#x6837;&#x7684;</p>
<pre><code class="lang-kotlin">list1 += <span class="hljs-number">1</span> <span class="hljs-comment">// Translates to list1.plusAssign(1) </span>
list2 += <span class="hljs-number">1</span> <span class="hljs-comment">// Translates to list2 = list2.plus(1)</span>
</code></pre>
<p>Both those ways are correct and they both have their pros and cons. They both have a single mutating point, but it is located in a different place. In the first one mutation takes place on the concrete list implementation. We might depend on the fact that it has proper synchronization in case of multithreading, but such an assumption is also dangerous since it is not really guaranteed. In the second one, we need to implement the synchronization ourselves, but the overall safety is better because the mutating point is only a single property. Though, in case of a lack of synchronization, remember that we can still lose some elements:</p>
<p>&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x90FD;&#x662F;&#x6B63;&#x786E;&#x7684;&#x5E76;&#x4E14;&#x90FD;&#x6709;&#x7740;&#x4ED6;&#x4EEC;&#x7684;&#x4F18;&#x70B9;&#x548C;&#x7F3A;&#x70B9;&#x3002;&#x4ED6;&#x4EEC;&#x90FD;&#x6709;&#x503C;&#x7684;&#x53D8;&#x5316;&#x8282;&#x70B9;&#xFF0C;&#x4F46;&#x4F4D;&#x4E8E;&#x4E0D;&#x540C;&#x7684;&#x5730;&#x65B9;&#x3002;&#x7B2C;&#x4E00;&#x4E2A;&#x4F8B;&#x5B50;&#xFF0C;&#x5BF9;&#x8C61;&#x7684;&#x53D8;&#x5316;&#x53D1;&#x751F;&#x5728;list&#x5B9E;&#x4F8B;&#x4E0A;&#x3001;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x4F9D;&#x8D56;&#x4E8E;&#x5B83;&#x5728;&#x591A;&#x7EBF;&#x7A0B;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x6709;&#x9002;&#x5F53;&#x7684;&#x540C;&#x6B65;&#x8FD9;&#x4E00;&#x4E8B;&#x5B9E;&#xFF0C;&#x4F46;&#x8FD9;&#x6837;&#x7684;&#x5047;&#x8BBE;&#x4E5F;&#x662F;&#x5371;&#x9669;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x5E76;&#x4E0D;&#x662F;&#x771F;&#x6B63;&#x4FDD;&#x8BC1;&#x7684;&#x3002;&#x5728;&#x7B2C;&#x4E8C;&#x79CD;&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x540C;&#x6B65;&#xFF0C;&#x4F46;&#x662F;&#x603B;&#x4F53;&#x5B89;&#x5168;&#x6027;&#x66F4;&#x597D;&#xFF0C;&#x56E0;&#x4E3A;&#x7A81;&#x53D8;&#x70B9;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x5355;&#x72EC;&#x7684;&#x5C5E;&#x6027;&#x3002;&#x5C3D;&#x7BA1;&#x5982;&#x6B64;&#xFF0C;&#x5728;&#x7F3A;&#x5C11;&#x540C;&#x6B65;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x8BF7;&#x8BB0;&#x4F4F;&#x6211;&#x4EEC;&#x4ECD;&#x7136;&#x4F1A;&#x4E22;&#x5931;&#x4E00;&#x4E9B;&#x5143;&#x7D20;:</p>
<pre><code class="lang-kotlin">ar list = listOf<span class="hljs-type">&lt;Int&gt;</span>()
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.1000</span>) {
   thread {
       list = list + i
   }
}
Thread.sleep(<span class="hljs-number">1000</span>)
print(list.size) <span class="hljs-comment">// Very unlikely to be 1000, </span>
<span class="hljs-comment">// every time a different number, like for instance 911</span>
</code></pre>
<p>Using a mutable property instead of a mutable list allows us to track how this property changes when we define a custom setter or using a delegate (which is using a custom setter). For instance, when we use an observable delegate, we can log every change of a list:
&#x4F7F;&#x7528;&#x53EF;&#x53D8;&#x5C5E;&#x6027;&#x800C;&#x4E0D;&#x662F;&#x53EF;&#x53D8;&#x5217;&#x8868;&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x5728;&#x5B9A;&#x4E49;&#x81EA;&#x5B9A;&#x4E49;setter&#x6216;&#x4F7F;&#x7528;&#x59D4;&#x6258;(&#x4F7F;&#x7528;&#x81EA;&#x5B9A;&#x4E49;setter)&#x65F6;&#x8DDF;&#x8E2A;&#x8BE5;&#x5C5E;&#x6027;&#x7684;&#x53D8;&#x5316;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x5F53;&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x53EF;&#x89C2;&#x5BDF;&#x59D4;&#x6258;&#x65F6;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x8BB0;&#x5F55;&#x5217;&#x8868;&#x7684;&#x6BCF;&#x4E00;&#x4E2A;&#x53D8;&#x5316;:</p>
<pre><code class="lang-kotlin">var names by Delegates.observable(listOf&lt;String&gt;()) { _, old, new -&gt;
   println(&quot;Names changed from $old to $new&quot;)
}

names += &quot;Fabio&quot; 
// Names changed from [] to [Fabio]
names += &quot;Bill&quot;   
// Names changed from [Fabio] to [Fabio, Bill]&#x201D;
</code></pre>
<p>To make this possible for a mutable collection, we would need a special observable implementation of the collection. For read-only collections on mutable properties, it is also easier to control how they change - there is only a setter instead of multiple methods mutating this object, and we can make it private:</p>
<p>&#x4E3A;&#x4E86;&#x4F7F;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x6210;&#x4E3A;&#x53EF;&#x80FD;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8BE5;&#x96C6;&#x5408;&#x7684;&#x7279;&#x6B8A;&#x53EF;&#x89C2;&#x5BDF;&#x5B9E;&#x73B0;&#x3002;&#x5BF9;&#x4E8E;&#x53EF;&#x53D8;&#x5C5E;&#x6027;&#x4E0A;&#x7684;&#x53EA;&#x8BFB;&#x96C6;&#x5408;&#xFF0C;&#x63A7;&#x5236;&#x5B83;&#x4EEC;&#x5982;&#x4F55;&#x6539;&#x53D8;&#x4E5F;&#x66F4;&#x5BB9;&#x6613;&#x2014;&#x2014;&#x53EA;&#x6709;&#x4E00;&#x4E2A;setter&#x800C;&#x4E0D;&#x662F;&#x591A;&#x4E2A;&#x65B9;&#x6CD5;&#x6539;&#x53D8;&#x4E86;&#x8FD9;&#x4E2A;&#x5BF9;&#x8C61;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x5C06;&#x5B83;&#x8BBE;&#x4E3A;&#x79C1;&#x6709;:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">var</span> announcements</span> = listOf<span class="hljs-type">&lt;Announcement&gt;</span>()
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>
</code></pre>
<p>In short, using mutable collections is a slightly faster option, but using a mutable property instead gives us more control over how the object is changing.
&#x7B80;&#x800C;&#x8A00;&#x4E4B;&#xFF0C;&#x4F7F;&#x7528;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x662F;&#x4E00;&#x79CD;&#x7A0D;&#x5FAE;&#x5FEB;&#x4E00;&#x70B9;&#x7684;&#x9009;&#x62E9;&#xFF0C;&#x4F46;&#x662F;&#x4F7F;&#x7528;&#x53EF;&#x53D8;&#x5C5E;&#x6027;&#x53EF;&#x4EE5;&#x8BA9;&#x6211;&#x4EEC;&#x5BF9;&#x5BF9;&#x8C61;&#x7684;&#x53D8;&#x5316;&#x65B9;&#x5F0F;&#x6709;&#x66F4;&#x591A;&#x7684;&#x63A7;&#x5236;&#x3002;</p>
<p>Notice that the worst solution is to have both a mutating property and a mutable collection:
&#x6CE8;&#x610F;&#xFF0C;&#x6700;&#x7CDF;&#x7CD5;&#x7684;&#x89E3;&#x51B3;&#x65B9;&#x6848;&#x662F;&#x540C;&#x65F6;&#x62E5;&#x6709;&#x4E00;&#x4E2A;&#x53EF;&#x53D8;&#x5C5E;&#x6027;&#x548C;&#x4E00;&#x4E2A;&#x53EF;&#x53D8;&#x96C6;&#x5408;:</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// Don&#x2019;t do that</span>
<span class="hljs-variable"><span class="hljs-keyword">var</span> list3</span> = mutableListOf<span class="hljs-type">&lt;Int&gt;</span>()
</code></pre>
<p>We would need to synchronize both ways it can mutate (by property change and by internal state change). Also, changing it using plus-assign is impossible because of ambiguity:</p>
<p>&#x6211;&#x4EEC;&#x9700;&#x8981;&#x540C;&#x6B65;&#x8FD9;&#x4E24;&#x79CD;&#x53EF;&#x80FD;&#x53D1;&#x751F;&#x53D8;&#x5316;&#x7684;&#x65B9;&#x5F0F;(&#x901A;&#x8FC7;&#x5C5E;&#x6027;&#x53D8;&#x5316;&#x548C;&#x5185;&#x90E8;&#x72B6;&#x6001;&#x53D8;&#x5316;)&#x3002;&#x6B64;&#x5916;&#xFF0C;&#x7531;&#x4E8E;&#x6A21;&#x7CCA;&#x6027;&#xFF0C;&#x4F7F;&#x7528;plus-assign&#x6765;&#x6539;&#x53D8;&#x5B83;&#x662F;&#x4E0D;&#x53EF;&#x80FD;&#x7684;:</p>
<p><img src="../../assets/chapter1/chapter1-2.png" alt=""></p>
<p>The general rule is that one should not create unnecessary ways to mutate state. Every way to mutate state is a cost. It needs to be understood and maintained. We prefer to limit mutability.</p>
<p>&#x4E00;&#x822C;&#x7684;&#x89C4;&#x5219;&#x662F;&#xFF0C;&#x4E0D;&#x5E94;&#x8BE5;&#x521B;&#x5EFA;&#x4E0D;&#x5FC5;&#x8981;&#x7684;&#x65B9;&#x6CD5;&#x6765;&#x6539;&#x53D8;&#x72B6;&#x6001;&#x3002;&#x4EFB;&#x4F55;&#x6539;&#x53D8;&#x72B6;&#x6001;&#x7684;&#x65B9;&#x6CD5;&#x90FD;&#x662F;&#x6709;&#x4EE3;&#x4EF7;&#x7684;&#x3002;&#x5B83;&#x9700;&#x8981;&#x88AB;&#x7406;&#x89E3;&#x548C;&#x7EF4;&#x62A4;&#x3002;&#x6211;&#x4EEC;&#x503E;&#x5411;&#x4E8E;&#x9650;&#x5236;&#x53EF;&#x53D8;&#x6027;&#x3002;</p>
<h4 id="do-not-leak-mutation-points">Do not leak mutation points</h4>
<h4 id="&#x8BF7;&#x52FF;&#x6CC4;&#x6F0F;&#x7A81;&#x53D8;&#x70B9;">&#x8BF7;&#x52FF;&#x6CC4;&#x6F0F;&#x7A81;&#x53D8;&#x70B9;</h4>
<p>It is an especially dangerous situation when we expose a mutable object that makes up state. Take a look at this example:
&#x5F53;&#x6211;&#x4EEC;&#x516C;&#x5F00;&#x7EC4;&#x6210;&#x72B6;&#x6001;&#x7684;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x8FD9;&#x662F;&#x4E00;&#x79CD;&#x7279;&#x522B;&#x5371;&#x9669;&#x7684;&#x60C5;&#x51B5;&#x3002;&#x770B;&#x770B;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;:</p>
<pre><code class="lang-kotlin">data <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> storedUsers</span>: MutableMap<span class="hljs-type">&lt;Int, String&gt;</span> = 
       mutableMapOf()

   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadAll</span><span class="hljs-params">()</span>: MutableMap<span class="hljs-type">&lt;Int, String&gt;</span> {</span>
       <span class="hljs-keyword">return</span> storedUsers
   }

   <span class="hljs-comment">//...</span>
}
</code></pre>
<p>One could use loadAll to modify UserRepository private state:</p>
<p>&#x53EF;&#x4EE5;&#x4F7F;&#x7528;loadAll&#x6765;&#x4FEE;&#x6539;UserRepository&#x7684;&#x79C1;&#x6709;&#x72B6;&#x6001;:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> userRepository</span> = UserRepository()

<span class="hljs-variable"><span class="hljs-keyword">val</span> storedUsers</span> = userRepository.loadAll()
storedUsers[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;Kirill&quot;</span>
<span class="hljs-comment">//...</span>

print(userRepository.loadAll()) <span class="hljs-comment">// {4=Kirill}</span>
</code></pre>
<p>It is especially dangerous when such modifications are accidental. There are two ways how we can deal with that. The first one is copying returned mutable objects. We call that defensive copying. This can be a useful technique when we deal with a standard objects and here copy generated by data modifier can be really helpful:</p>
<p>&#x5982;&#x679C;&#x8FD9;&#x79CD;&#x6539;&#x53D8;&#x662F;&#x5076;&#x7136;&#x7684;&#xFF0C;&#x5C31;&#x7279;&#x522B;&#x5371;&#x9669;&#x3002;&#x6709;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x89E3;&#x51B3;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;&#x3002;&#x7B2C;&#x4E00;&#x4E2A;&#x662F;&#x590D;&#x5236;&#x8FD4;&#x56DE;&#x7684;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x3002;&#x6211;&#x4EEC;&#x79F0;&#x4E4B;&#x4E3A;&#x9632;&#x5FA1;&#x6027;&#x590D;&#x5236;&#x3002;&#x5F53;&#x6211;&#x4EEC;&#x5904;&#x7406;&#x6807;&#x51C6;&#x5BF9;&#x8C61;&#x65F6;&#xFF0C;&#x8FD9;&#x662F;&#x4E00;&#x79CD;&#x6709;&#x7528;&#x7684;&#x6280;&#x672F;&#xFF0C;&#x8FD9;&#x91CC;&#x7531;data modifier&#x751F;&#x6210;&#x7684;&#x526F;&#x672C;&#x975E;&#x5E38;&#x6709;&#x7528;:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserHolder</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> user</span>: MutableUser()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">()</span>: MutableUser {</span>
        <span class="hljs-keyword">return</span> user.copy()
    }

    <span class="hljs-comment">//...</span>
}
</code></pre>
<p>Though whenever possible we prefer limiting mutability, and for collections we can do that by upcasting those objects to their read-only supertype:
&#x4E0D;&#x8FC7;&#x53EA;&#x8981;&#x6709;&#x53EF;&#x80FD;&#xFF0C;&#x6211;&#x4EEC;&#x66F4;&#x559C;&#x6B22;&#x9650;&#x5236;&#x53EF;&#x53D8;&#x6027;&#xFF0C;&#x5BF9;&#x4E8E;&#x96C6;&#x5408;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5C06;&#x8FD9;&#x4E9B;&#x5BF9;&#x8C61;&#x5411;&#x4E0A;&#x8F6C;&#x6362;&#x4E3A;&#x5B83;&#x4EEC;&#x7684;&#x53EA;&#x8BFB;&#x8D85;&#x7C7B;&#x578B;&#x6765;&#x5B9E;&#x73B0;:</p>
<pre><code class="lang-kotlin">data <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> storedUsers</span>: MutableMap<span class="hljs-type">&lt;Int, String&gt;</span> = 
       mutableMapOf()

   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadAll</span><span class="hljs-params">()</span>: Map<span class="hljs-type">&lt;Int, String&gt;</span> {</span>
       <span class="hljs-keyword">return</span> storedUsers
   }

   <span class="hljs-comment">//...</span>
}
</code></pre>
<h4 id="summary">Summary</h4>
<p>In this chapter we&#x2019;ve learned why it is important to limit mutability and to prefer immutable objects. We&#x2019;ve seen that Kotlin gives us a lot of tools that support limiting mutability. We should use them to limit mutation points. Simple rules are:
&#x5728;&#x672C;&#x7AE0;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5B66;&#x4E60;&#x4E86;&#x4E3A;&#x4EC0;&#x4E48;&#x9650;&#x5236;&#x53EF;&#x53D8;&#x6027;&#x548C;&#x9009;&#x62E9;&#x4E0D;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x662F;&#x91CD;&#x8981;&#x7684;&#x3002;&#x6211;&#x4EEC;&#x5DF2;&#x7ECF;&#x770B;&#x5230;Kotlin&#x4E3A;&#x6211;&#x4EEC;&#x63D0;&#x4F9B;&#x4E86;&#x8BB8;&#x591A;&#x652F;&#x6301;&#x9650;&#x5236;&#x53EF;&#x53D8;&#x6027;&#x7684;&#x5DE5;&#x5177;&#x3002;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x7528;&#x5B83;&#x4EEC;&#x6765;&#x9650;&#x5236;&#x7A81;&#x53D8;&#x70B9;&#x3002;&#x7B80;&#x5355;&#x7684;&#x89C4;&#x5219;&#x662F;:</p>
<ul>
<li>Prefer val over var.</li>
<li>&#x66F4;&#x591A;&#x7684;&#x4F7F;&#x7528;val &#x800C;&#x4E0D;&#x662F;var</li>
<li>Prefer an immutable property over a mutable one.</li>
<li>&#x6700;&#x597D;&#x4F7F;&#x7528;&#x4E0D;&#x53EF;&#x53D8;&#x5C5E;&#x6027;&#x800C;&#x4E0D;&#x662F;&#x53EF;&#x53D8;&#x5C5E;&#x6027;</li>
<li>Prefer objects and classes that are immutable over mutable.</li>
<li>&#x4F18;&#x5148;&#x9009;&#x62E9;&#x4E0D;&#x53EF;&#x53D8;&#x7684;&#x5BF9;&#x8C61;&#x548C;&#x7C7B;&#x800C;&#x4E0D;&#x662F;&#x53EF;&#x53D8;&#x7684;&#x3002;</li>
<li>If you need them to change, consider making them immutable data classes, and using copy.</li>
<li>&#x5982;&#x679C;&#x9700;&#x8981;&#x66F4;&#x6539;&#x5B83;&#x4EEC;&#xFF0C;&#x8BF7;&#x8003;&#x8651;&#x5C06;&#x5B83;&#x4EEC;&#x8BBE;&#x7F6E;&#x4E3A;&#x4E0D;&#x53EF;&#x53D8;&#x6570;&#x636E;&#x7C7B;&#xFF0C;&#x5E76;&#x4F7F;&#x7528;copy&#x3002;</li>
<li>When you hold state, prefer read-only over mutable collections.</li>
<li>&#x5F53;&#x60A8;&#x4FDD;&#x5B58;&#x72B6;&#x6001;&#x65F6;&#xFF0C;&#x6700;&#x597D;&#x662F;&#x53EA;&#x8BFB;&#x800C;&#x4E0D;&#x662F;&#x53EF;&#x53D8;&#x96C6;&#x5408;&#x3002;</li>
<li>Design your mutation points wisely and do not produce unnecessary ones.</li>
<li>&#x660E;&#x667A;&#x5730;&#x8BBE;&#x8BA1;&#x4F60;&#x7684;&#x7A81;&#x53D8;&#x70B9;&#xFF0C;&#x4E0D;&#x8981;&#x4EA7;&#x751F;&#x4E0D;&#x5FC5;&#x8981;&#x7684;&#x7A81;&#x53D8;&#x70B9;&#x3002;</li>
<li>Do not expose mutable objects.</li>
<li>&#x4E0D;&#x8981;&#x66B4;&#x9732;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#x3002;</li>
</ul>
<p>There are some exceptions to these rules. Sometimes we prefer a mutable object because they are more efficient. Such optimizations should be preferred only in the performance critical parts of our code (Part 3: Efficiency) and when we use them, we need to remember that mutability requires more attention when we prepare it for multithreading. The baseline is that we should limit mutability.</p>
<p>&#x8FD9;&#x4E9B;&#x89C4;&#x5219;&#x4E5F;&#x6709;&#x4E00;&#x4E9B;&#x4F8B;&#x5916;&#x3002;&#x6709;&#x65F6;&#x6211;&#x4EEC;&#x66F4;&#x559C;&#x6B22;&#x53EF;&#x53D8;&#x5BF9;&#x8C61;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x66F4;&#x9AD8;&#x6548;&#x3002;&#x8FD9;&#x79CD;&#x4F18;&#x5316;&#x5E94;&#x8BE5;&#x53EA;&#x9002;&#x7528;&#x4E8E;&#x4EE3;&#x7801;&#x7684;&#x6027;&#x80FD;&#x5173;&#x952E;&#x90E8;&#x5206;(&#x7B2C;3&#x90E8;&#x5206;:&#x6548;&#x7387;)&#xFF0C;&#x5F53;&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x5B83;&#x4EEC;&#x65F6;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8BB0;&#x4F4F;&#xFF0C;&#x5728;&#x4E3A;&#x591A;&#x7EBF;&#x7A0B;&#x51C6;&#x5907;&#x53EF;&#x53D8;&#x6027;&#x65F6;&#x9700;&#x8981;&#x66F4;&#x591A;&#x7684;&#x6CE8;&#x610F;&#x3002;&#x5E95;&#x7EBF;&#x662F;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x9650;&#x5236;&#x53EF;&#x53D8;&#x6027;&#x3002;</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Introduction.html" class="navigation navigation-prev " aria-label="Previous page: 引言">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Item 2 Minimize the scope of variables.html" class="navigation navigation-next " aria-label="Next page: 第2条：最小化变量作用域">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Item 1 Limit Mutability","level":"1.2.1.2","depth":3,"next":{"title":"第2条：最小化变量作用域","level":"1.2.1.3","depth":3,"path":"Part 1 Good code/Chapter 1 Safety/Item 2 Minimize the scope of variables.md","ref":"Part 1 Good code/Chapter 1 Safety/Item 2 Minimize the scope of variables.md","articles":[]},"previous":{"title":"引言","level":"1.2.1.1","depth":3,"path":"Part 1 Good code/Chapter 1 Safety/Introduction.md","ref":"Part 1 Good code/Chapter 1 Safety/Introduction.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Part 1 Good code/Chapter 1 Safety/Item 1 Limit mutability.md","mtime":"2022-01-15T09:19:03.965Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-01-15T09:19:42.537Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

