## Item 16: Properties should represent state, not behavior
## 属性应该代表状态，而不是行为

Kotlin properties look similar to Java fields, but they actually represent a different concept. 
Kotlin属性看起来类似于Java字段，但它们实际上代表不同的概念。

``` kotlin
// Kotlin property
var name: String? = null

// Java field
String name = null;
```

Even though they can be used the same way, to hold data, we need to remember that properties have many more capabilities. Starting with the fact that they can always have custom setters and getters:
尽管可以以相同的方式使用属性来保存数据，但我们需要记住属性还有更多的功能。首先，它们总是可以有自定义的setter和getter:

``` kotlin
var name: String? = null
   get() = field?.toUpperCase()
   set(value) {
       if(!value.isNullOrBlank()) {
           field = value
       }
   }
```

You can see here that we are using the `field` identifier. This is a reference to the backing field that lets us hold data in this property. Such backing fields are generated by default because default implementations of setter and getter use them. We can also implement custom accessors that do not use them, and in such a case a property will not have a `field` at all. For instance, a Kotlin property can be defined using only a getter for a read-only property `val`: 
您可以在这里看到，我们正在使用' field '标识符。这是对支持字段的引用，该字段允许我们在此属性中保存数据。这种支持字段是在默认情况下生成的，因为setter和getter的默认实现使用它们。我们还可以实现不使用它们的自定义访问器，在这种情况下，属性将根本没有“字段”。例如，Kotlin属性可以只使用只读属性' val '的getter来定义:

``` kotlin
val fullName: String
   get() = "$name $surname"
```

For a read-write property `var,` we can make a property by defining a getter and setter. Such properties are known as *derived properties*, and they are not uncommon. They are the main reason why all properties in Kotlin are encapsulated by default. Just imagine that you have to hold a date in your object and you used `Date` from the Java stdlib. Then at some point for a reason, the object cannot store the property of this type anymore. Perhaps because of a serialization issue, or maybe because you lifted this object to a common module. The problem is that this property has been referenced throughout your project. With Kotlin, this is no longer a problem, as you can move your data into a separate property `millis`, and modify the `date` property to not hold data but instead to wrap/unwrap that other property. 

对于读写属性“var”，我们可以通过定义getter和setter来创建属性。这些属性被称为“派生属性”，它们并不罕见。它们是Kotlin中默认封装所有属性的主要原因。想象一下，你必须在你的对象中保存一个日期，你使用了Java标准库中的“日期”。然后在某个时刻，由于某种原因，对象不能再存储此类型的属性。可能是因为序列化问题，也可能是因为将此对象提升到公共模块。问题是这个属性已经被其他引用了

``` kotlin
var date: Date
   get() = Date(millis)
   set(value) {
       millis = value.time
   }
```

Properties do not need fields. Rather, they conceptually represent accessors (getter for `val`, getter and setter for `var`). This is why we can define them in interfaces:
属性不需要字段。相反，它们在概念上表示访问器(getter用于' val '， getter和setter用于' var ')。这就是为什么我们可以在接口中定义它们:

``` kotlin
interface Person {
   val name: String
}
```

This means that this interface promises to have a getter. We can also override properties:

这意味着该接口承诺有一个getter。我们也可以重写属性:

``` kotlin
open class Supercomputer {
   open val theAnswer: Long = 42
}

class AppleComputer : Supercomputer() {
   override val theAnswer: Long = 1_800_275_2273
}
```

For the same reason, we can delegate properties:
出于同样的原因，我们可以委托属性:

``` kotlin
val db: Database by lazy { connectToDb() }
```

Property delegation is described in detail in Item 21: Use property delegation to extract common property patterns. Because properties are essentially functions, we can make extension properties as well:
属性委托在21节:使用属性委托提取通用属性模式中进行了详细描述。因为属性本质上是函数，所以我们也可以创建扩展属性:

``` kotlin
val Context.preferences: SharedPreferences
   get() = PreferenceManager
       .getDefaultSharedPreferences(this)

val Context.inflater: LayoutInflater
   get() = getSystemService(
       Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater

val Context.notificationManager: NotificationManager
   get() = getSystemService(Context.NOTIFICATION_SERVICE) 
       as NotificationManager
```

As you can see, **properties represent accessors, not fields**. This way they can be used instead of some functions, but we should be careful what we use them for. Properties should not be used to represent algorithmic behaviour like in the example below:

如您所见，**属性表示访问器，而不是字段**。这样就可以使用它们来代替某些函数，但是我们应该注意使用它们的目的。属性不应该被用来表示如下例子中的算法行为:

``` kotlin
// DON’T DO THIS!
val Tree<Int>.sum: Int
   get() = when (this) {
       is Leaf -> value
       is Node -> left.sum + right.sum
   }
```

Here `sum` property iterates over all elements and so it represents algorithmic behavior. Therefore this property is misleading: finding the answer can be computationally heavy for big collections, and this is not expected at all for a getter. This should not be a property, this should be a function:
这里的“sum”属性遍历所有元素，因此它代表算法行为。因此，这个属性具有误导性:对于大型集合来说，找到答案的计算量会很大，而getter根本不需要这样做。这不应该是一个属性，而应该是一个函数:

``` kotlin
fun Tree<Int>.sum(): Int = when (this) {
   is Leaf -> value
   is Node -> left.sum() + right.sum()
}
```

The general rule is that **we should use them only to represent or set state, and no other logic should be involved**. A useful heuristic to decide if something should be a property is: If I would define this property as a function, would I prefix it with get/set? If not, it should rather not be a property. More concretely, here are the most typical situations when we should not use properties, and we should use functions instead:
一般的规则是**我们应该只使用它们来表示或设置状态，不应该涉及其他逻辑**。决定某个属性是否应该是属性的一个有用的启发式方法是:如果我将这个属性定义为一个函数，我会在它的前缀上加上get/set吗?如果不是，它就不应该是一个属性。更具体地说，以下是我们不应该使用属性而应该使用函数的最典型的情况:

- **Operation is computationally expensive or has computational complexity higher than O(1)** - A user does not expect that using a property might be expensive. If it is, using a function is better because it communicates that it might be and that user might be parsimonious using it, or the developer might consider caching it.
- **It involves business logic (how the application acts)** - when we read code, we do not expect that a property might do anything more than simple actions like logging, notifying listeners, or updating a bound element. 
- **It is not deterministic** - Calling the member twice in succession produces different results.
- **It is a conversion, such as** `Int.toDouble()` - It is a matter of convention that conversions are a method or an extension function. Using a property would seem like referencing some inner part instead of wrapping the whole object. 
- **Getters should not change property state** - We expect that we can use getters freely without worrying about property state modifications. 

For instance, calculating the sum of elements requires iterating over all of the elements (this is behavior, not state) and has linear complexity. Therefore it should not be a property, and is defined in the standard library as a function:
例如，计算元素的总和需要遍历所有元素(这是行为，而不是状态)，并且具有线性复杂性。因此它不应该是一个属性，而应该在标准库中定义为一个函数:

``` kotlin
val s = (1..100).sum()
```

On the other hand, to get and set state we use properties in Kotlin, and we should not involve functions unless there is a good reason. We use properties to represent and set state, and if you need to modify them later, use custom getters and setters:、

另一方面，为了获取和设置状态，我们在Kotlin中使用属性，除非有充分的理由，否则我们不应该使用函数。我们使用属性来表示和设置状态，如果以后需要修改它们，可以使用自定义的getter和setter:

``` kotlin
// DON’T DO THIS!
class UserIncorrect {
   private var name: String = ""
  
   fun getName() = name
  
   fun setName(name: String) {
       this.name = name
   }
}

class UserCorrect {
   var name: String = ""
}
```

A simple rule of thumb is that **a property describes and sets state, while a function describes behavior**.
一个简单的经验法则是:属性描述并设置状态，而函数描述行为。
